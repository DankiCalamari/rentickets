/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Task } from '@lit/task';
import { LitElement, html } from 'lit';
import { state } from 'lit/decorators.js';
import { ProviderState } from '../providers/IProvider';
import { Providers } from '../providers/Providers';
import { LocalizationHelper } from '../utils/LocalizationHelper';
import { PACKAGE_VERSION } from '../utils/version';
import { ComponentMediaQuery } from './baseComponent';
/**
 * BaseComponent extends LitElement adding mgt specific features to all components
 *
 * @export  MgtBaseTaskComponent
 * @abstract
 * @class MgtBaseTaskComponent
 * @extends {LitElement}
 */
export class MgtBaseTaskComponent extends LitElement {
    /**
     * Exposes the semver of the library the component is part of
     *
     * @readonly
     * @static
     * @memberof MgtBaseTaskComponent
     */
    static get packageVersion() {
        return PACKAGE_VERSION;
    }
    /**
     * Gets the ComponentMediaQuery of the component
     *
     * @readonly
     * @type {MgtElement.ComponentMediaQuery}
     * @memberof MgtBaseTaskComponent
     */
    get mediaQuery() {
        if (this.offsetWidth < 768) {
            return ComponentMediaQuery.mobile;
        }
        else if (this.offsetWidth < 1200) {
            return ComponentMediaQuery.tablet;
        }
        else {
            return ComponentMediaQuery.desktop;
        }
    }
    /**
     * A flag to check if the component has updated once.
     *
     * @readonly
     * @protected
     * @type {boolean}
     * @memberof MgtBaseTaskComponent
     */
    get isFirstUpdated() {
        return this._isFirstUpdated;
    }
    /**
     * returns component strings
     *
     * @readonly
     * @protected
     * @memberof MgtBaseTaskComponent
     */
    get strings() {
        return {};
    }
    constructor() {
        super();
        /**
         * Supplies the component with a reactive property based on the current provider state
         *
         * @protected
         * @memberof MgtBaseTaskComponent
         */
        this.providerState = ProviderState.Loading;
        /**
         * Gets or sets the direction of the component
         *
         * @protected
         * @memberof MgtBaseTaskComponent
         */
        this.direction = 'ltr';
        this._isFirstUpdated = false;
        /**
         * Task that is run whenever one of the args changes
         * By default this task will call loadState
         */
        this._task = new Task(this, {
            task: () => this.loadState(),
            args: () => this.args()
        });
        /**
         * A default loading template.
         * @returns default loading template
         */
        this.renderLoading = () => {
            return html `<span>Loading...</span>`;
        };
        this.renderError = (e) => {
            return html `<p>Error: ${e}</p>`;
        };
        this.renderContent = () => {
            return html `<!-- baseTaskComponent, please implement renderContent -->`;
        };
        this.handleProviderUpdates = () => {
            var _a, _b;
            this.providerState = (_b = (_a = Providers.globalProvider) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : ProviderState.Loading;
        };
        this.handleActiveAccountUpdates = () => {
            this.clearState();
        };
        this.handleLocalizationChanged = () => {
            LocalizationHelper.updateStringsForTag(this.tagName, this.strings);
            this.requestUpdate();
        };
        this.handleDirectionChanged = () => {
            this.direction = LocalizationHelper.getDocumentDirection();
        };
        this.handleDirectionChanged();
        this.handleLocalizationChanged();
    }
    /**
     * Invoked each time the custom element is appended into a document-connected element
     *
     * @memberof MgtBaseTaskComponent
     */
    connectedCallback() {
        super.connectedCallback();
        LocalizationHelper.onStringsUpdated(this.handleLocalizationChanged);
        LocalizationHelper.onDirectionUpdated(this.handleDirectionChanged);
    }
    /**
     * Invoked each time the custom element is removed from a document-connected element
     *
     * @memberof MgtBaseTaskComponent
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        LocalizationHelper.removeOnStringsUpdated(this.handleLocalizationChanged);
        LocalizationHelper.removeOnDirectionUpdated(this.handleDirectionChanged);
        Providers.removeProviderUpdatedListener(this.handleProviderUpdates);
        Providers.removeActiveAccountChangedListener(this.handleActiveAccountUpdates);
    }
    /**
     * Invoked when the element is first updated. Implement to perform one time
     * work on the element after update.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * @param _changedProperties Map of changed properties with old values
     */
    firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        this._isFirstUpdated = true;
        Providers.onProviderUpdated(this.handleProviderUpdates);
        Providers.onActiveAccountChanged(this.handleActiveAccountUpdates);
    }
    /**
     * Used to clear state in inherited components
     */
    clearState() {
        // no-op
    }
    /**
     * helps facilitate creation of events across components
     *
     * @protected
     * @param {string} eventName
     * @param {*} [detail]
     * @param {boolean} [bubbles=false]
     * @param {boolean} [cancelable=false]
     * @param {boolean} [composed=false]
     * @return {*}  {boolean}
     * @memberof MgtBaseTaskComponent
     */
    fireCustomEvent(eventName, detail, bubbles = false, cancelable = false, composed = false) {
        const event = new CustomEvent(eventName, {
            bubbles,
            cancelable,
            composed,
            detail
        });
        return this.dispatchEvent(event);
    }
    /**
     * Invoked whenever the element is updated. Implement to perform
     * post-updating tasks via DOM APIs, for example, focusing an element.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * * @param changedProperties Map of changed properties with old values
     */
    updated(changedProperties) {
        super.updated(changedProperties);
        this.fireCustomEvent('updated', undefined, true, false);
    }
    /**
     * load state into the component.
     * Override this function to provide actual loading logic.
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve();
        });
    }
    /**
     * Override this function to provide the actual list of properties to trigger the task to run.
     * The default implementation returns an array with the providerState.
     * @returns {unknown[]} the properties when changed which trigger the Task to run
     */
    args() {
        return [this.providerState];
    }
    /**
     * Invoked on each update to perform rendering tasks. This method must return
     * a lit-html TemplateResult. Setting properties inside this method will *not*
     * trigger the element to update.
     */
    render() {
        return this._task.render({
            pending: this.renderLoading,
            complete: this.renderContent,
            error: this.renderError
        });
    }
}
__decorate([
    state(),
    __metadata("design:type", Number)
], MgtBaseTaskComponent.prototype, "providerState", void 0);
__decorate([
    state(),
    __metadata("design:type", String)
], MgtBaseTaskComponent.prototype, "direction", void 0);
//# sourceMappingURL=baseTaskComponent.js.map