/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { html, nothing } from 'lit';
import { state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { repeat } from 'lit/directives/repeat.js';
import { fluentCheckbox, fluentRadioGroup, fluentButton } from '@fluentui/web-components';
import { mgtHtml, registerComponent, Providers, ProviderState } from '@microsoft/mgt-element';
import { createTodoTask, deleteTodoTask, getTodoTaskList, getTodoTaskLists, getTodoTasks, updateTodoTask } from './graph.todo';
import { styles } from './mgt-todo-css';
import { strings } from './strings';
import { registerMgtPickerComponent } from '../mgt-picker/mgt-picker';
import { MgtTasksBase } from '../mgt-tasks-base/mgt-tasks-base';
import { registerFluentComponents } from '../../utils/FluentComponents';
import { isElementDark } from '../../utils/isDark';
import { getSvg, SvgIcon } from '../../utils/SvgHelper';
export const registerMgtTodoComponent = () => {
    registerFluentComponents(fluentCheckbox, fluentRadioGroup, fluentButton);
    registerMgtPickerComponent();
    registerComponent('todo', MgtTodo);
};
/**
 * component enables the user to view, add, remove, complete, or edit todo tasks. It works with tasks in Microsoft Planner or Microsoft To-Do.
 *
 * @export
 * @class MgtTodo
 * @extends {MgtTasksBase}
 *
 * @cssprop --task-color - {Color} - Task text color
 * @cssprop --task-background-color - {Color} - Task background color
 * @cssprop --task-complete-background - {Color} - Task background color when completed
 * @cssprop --task-date-input-active-color - {Color} - Task date input active color
 * @cssprop --task-date-input-hover-color - {Color} - Task date input hover color
 * @cssprop --task-background-color-hover - {Color} - Task background when hovered
 * @cssprop --task-box-shadow - {Color} - Task box shadow color
 * @cssprop --task-border-completed - {Color} - Task border color when completed
 * @cssprop --task-radio-background-color - {Color} - Task radio background color
 */
export class MgtTodo extends MgtTasksBase {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    /**
     * Strings for localization
     *
     * @readonly
     * @protected
     * @memberof MgtTodo
     */
    get strings() {
        return strings;
    }
    /**
     * Get the scopes required for todo
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtTodo
     */
    static get requiredScopes() {
        return ['tasks.read', 'tasks.readwrite'];
    }
    constructor() {
        super();
        this._isChangedDueDate = false;
        this._isDarkMode = false;
        this.onThemeChanged = () => {
            this._isDarkMode = isElementDark(this);
        };
        /**
         * Render the panel for creating a new task
         *
         * @protected
         * @returns {TemplateResult}
         * @memberof MgtTodo
         */
        this.renderNewTask = () => {
            const addIcon = this._newTaskName
                ? html `
        <fluent-checkbox
          class="task-add-icon"
          @click="${this.addTask}">
        </fluent-checkbox>
      `
                : html `
        <span class="add-icon">${getSvg(SvgIcon.Add)}</span>
      `;
            const cancelIcon = html `
      <fluent-button
        aria-label=${this.strings.cancelAddingTask}
        class="task-cancel-icon" 
        @click="${this.clearNewTaskData}"
      >
        ${getSvg(SvgIcon.Cancel)}
      </fluent-button>
    `;
            const dateClass = { dark: this._isDarkMode, date: true };
            const calendarTemplate = html `
      <fluent-text-field
        autocomplete="off"
        type="date"
        id="new-taskDate-input"
        class="${classMap(dateClass)}"
        aria-label="${this.strings.newTaskDateInputLabel}"
        .value="${this.dateToInputValue(this._newTaskDueDate)}"
        @change="${this.handleDateChange}"
      >
      </fluent-text-field>
    `;
            const newTaskDetails = this.readOnly
                ? nothing
                : html `
      <fluent-text-field
        autocomplete="off"
        appearance="outline"
        class="new-task"
        id="new-task-name-input"
        aria-label="${this.strings.newTaskLabel}"
        .value=${this._newTaskName}
        placeholder="${this.strings.newTaskPlaceholder}"
        @keydown="${this.handleKeyDown}"
        @input="${this.handleInput}"
      >
        <div slot="start" class="start">${addIcon}</div>
        ${this._newTaskName
                    ? html `
              <div slot="end" class="end">
                <span class="calendar">${calendarTemplate}</span>
                ${cancelIcon}
              </div> `
                    : html ``}
      </fluent-text-field>
    `;
            return html `
      ${this.currentList
                ? html `
            <div dir=${this.direction} class="task new-task incomplete">
              ${newTaskDetails}
            </div>
        `
                : html ``}  
     `;
        };
        /**
         * Handle a change in taskList.
         *
         * @protected
         * @param {CustomEvent} e
         * @returns {TemplateResult}
         * @memberof MgtTodo
         */
        this.handleSelectionChanged = (e) => {
            this.currentList = e.detail;
            void this.loadTasks(this.currentList);
        };
        /**
         * Render task details.
         *
         * @protected
         * @param {TodoTask} task
         * @returns {TemplateResult}
         * @memberof MgtTodo
         */
        this.renderTaskDetails = (task) => {
            const context = { task, list: this.currentList };
            if (this.hasTemplate('task')) {
                return this.renderTemplate('task', context, task.id);
            }
            let taskDetailsTemplate = null;
            const taskDeleteTemplate = html `
      <fluent-button class="task-delete"
        @click="${() => this.removeTask(task.id)}"
        aria-label="${this.strings.deleteTaskOption}">
        ${getSvg(SvgIcon.Delete)}
      </fluent-button>`;
            if (this.hasTemplate('task-details')) {
                taskDetailsTemplate = this.renderTemplate('task-details', context, `task-details-${task.id}`);
            }
            else {
                const dateClass = { dark: this._isDarkMode, date: true, 'task-due': true };
                const calendarTemplate = html `
        <fluent-text-field
          autocomplete="off"
          type="date"
          id="${task.id}-taskDate-input"
          class="${classMap(dateClass)}"
          aria-label="${this.strings.changeTaskDateInputLabel}"
          .value="${task.dueDateTime
                    ? this.dateToInputValue(new Date(task.dueDateTime.dateTime))
                    : this._taskBeingUpdated === task
                        ? this.dateToInputValue(this._newTaskDueDate)
                        : nothing}"
          @change="${this.handleDateUpdate}"
          @focus="${(e) => this.updatingTask(e, task)}"
          @blur="${this.handleBlur}"
        >
        </fluent-text-field>
      `;
                const changeTaskDetailsTemplate = html `
          <fluent-text-field 
            autocomplete="off"
            appearance="outline"
            class="title"
            id=${task.id}
            .value="${task.title ? task.title : this._taskBeingUpdated === task ? this._changedTaskName : ''}"
            aria-label="${this.strings.editTaskLabel}"
            @keydown="${(e) => this.handleChange(e, task)}"
            @input="${(e) => this.handleChange(e, task)}"
            @focus="${(e) => this.updatingTask(e, task)}"
          >
          </fluent-text-field>
          ${task.dueDateTime || this._taskBeingUpdated === task ? html `${calendarTemplate}` : nothing}
          ${taskDeleteTemplate}
      `;
                taskDetailsTemplate = html `
      <div class="task-details">
        ${changeTaskDetailsTemplate}
      </div>
      `;
            }
            return html `${taskDetailsTemplate}`;
        };
        /**
         * Render a task in the list.
         *
         * @protected
         * @param {TodoTask} task
         * @returns {TemplateResult}
         * @memberof MgtTodo
         */
        this.renderTask = (task) => {
            const isCompleted = task.status === 'completed';
            const taskClasses = classMap({
                complete: isCompleted,
                'read-only': this.readOnly,
                task: true
            });
            const checkboxClasses = classMap({
                complete: isCompleted
            });
            const taskCheckContent = html `${getSvg(SvgIcon.CheckMark)}`;
            return html `
      <div class=${taskClasses} @blur="${this.handleBlur}">
        <fluent-checkbox 
          id=${task.id} 
          class=${checkboxClasses}
          ?checked=${isCompleted}
          @click="${() => this.handleTaskCheckClick(task)}"
          @keydown="${(e) => this.handleTaskCheckKeydown(e, task)}"
        >
          <div slot="checked-indicator">
            ${taskCheckContent}
          </div>
        </fluent-checkbox>
        ${this.renderTaskDetails(task)}
      </div>
    `;
        };
        /**
         * loads tasks from dataSource
         *
         * @returns {Promise<void>}
         * @memberof MgtTodo
         */
        this.loadState = () => __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            if (!provider || provider.state !== ProviderState.SignedIn) {
                return;
            }
            if (!this._graph) {
                const graph = provider.graph.forComponent(this);
                this._graph = graph;
            }
            if (!this.currentList && !this.initialId) {
                const lists = yield getTodoTaskLists(this._graph);
                const defaultList = lists === null || lists === void 0 ? void 0 : lists.find(l => l.wellknownListName === 'defaultList');
                if (defaultList)
                    yield this.loadTasks(defaultList);
            }
            if (this.targetId) {
                // Call to get the displayName of the list
                this.currentList = yield getTodoTaskList(this._graph, this.targetId);
                this._tasks = yield getTodoTasks(this._graph, this.targetId);
            }
            else if (this.initialId) {
                // Call to get the displayName of the list
                this.currentList = yield getTodoTaskList(this._graph, this.initialId);
                this._tasks = yield getTodoTasks(this._graph, this.initialId);
            }
        });
        /**
         * Create a new todo task and add it to the list
         *
         * @protected
         * @returns {Promise<void>}
         * @memberof MgtTodo
         */
        this.addTask = () => __awaiter(this, void 0, void 0, function* () {
            if (this._isNewTaskBeingAdded || !this._newTaskName) {
                return;
            }
            this._isNewTaskBeingAdded = true;
            try {
                yield this.createNewTask();
            }
            finally {
                this.clearNewTaskData();
                this._isNewTaskBeingAdded = false;
            }
        });
        /**
         *Update a todo task in the todo list
         * @protected
         * @returns {Promise<void>}
         * @memberof MgtTodo
         */
        this.updateTask = (task) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this._changedTaskName && !this._isChangedDueDate) {
                    return;
                }
                yield this.updateTaskItem(task);
            }
            finally {
                this.clearNewTaskData();
            }
        });
        /**
         * Clear out the new task metadata input fields
         *
         * @protected
         * @memberof MgtTodo
         */
        this.clearNewTaskData = () => {
            this._newTaskDueDate = null;
            this._newTaskName = '';
            this._changedTaskName = '';
            this._isChangedDueDate = false;
            this.focusOnTaskInput();
        };
        this.focusOnTaskInput = () => {
            const taskInputWrapper = this.renderRoot.querySelector('#new-task-name-input');
            const input = taskInputWrapper === null || taskInputWrapper === void 0 ? void 0 : taskInputWrapper.shadowRoot.querySelector('input');
            if (input) {
                input.focus();
            }
        };
        /**
         * Clear the state of the component
         *
         * @protected
         * @memberof MgtTodo
         */
        this.clearState = () => {
            super.clearState();
            this.currentList = null;
            this._tasks = [];
            this._taskBeingUpdated = null;
        };
        this.loadTasks = (list) => __awaiter(this, void 0, void 0, function* () {
            this.currentList = list;
            this._tasks = yield getTodoTasks(this._graph, list.id);
        });
        this.updateTaskStatus = (task, taskStatus) => __awaiter(this, void 0, void 0, function* () {
            // Change the task status
            task.status = taskStatus;
            // Send update request
            const listId = this.currentList.id;
            task = yield updateTodoTask(this._graph, listId, task.id, task);
            const taskIndex = this._tasks.findIndex(t => t.id === task.id);
            this._tasks[taskIndex] = task;
            yield this._task.run();
        });
        this.removeTask = (taskId) => __awaiter(this, void 0, void 0, function* () {
            this._tasks = this._tasks.filter(t => t.id !== taskId);
            this.requestUpdate();
            const listId = this.currentList.id;
            yield deleteTodoTask(this._graph, listId, taskId);
            this._tasks = this._tasks.filter(t => t.id !== taskId);
        });
        this.handleInput = (e) => {
            if (e.target.id === 'new-task-name-input') {
                this._newTaskName = e.target.value;
            }
        };
        this.handleChange = (e, task) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (e.target.id === task.id) {
                if (e.key === 'Enter') {
                    yield this.updateTask(task);
                    (_a = e.target) === null || _a === void 0 ? void 0 : _a.blur();
                }
                this._changedTaskName = e.target.value;
            }
        });
        this.handleKeyDown = (e) => __awaiter(this, void 0, void 0, function* () {
            if (e.key === 'Enter' && e.target.id === 'new-task-name-input') {
                yield this.addTask();
            }
        });
        this.updatingTask = (e, task) => {
            if (e.target.id === task.id) {
                this._taskBeingUpdated = task;
            }
            if (e.target.id === `${task.id}-taskDate-input`) {
                this._updatingTaskDate = true;
                this._taskBeingUpdated = task;
            }
        };
        this.handleBlur = () => {
            const task = this._taskBeingUpdated;
            const targets = this.renderRoot.querySelectorAll('fluent-text-field');
            for (const target of targets) {
                if (task &&
                    (target.id === task.id || target.id === `${task.id}-taskDate-input`)) {
                    void this.updateTask(task);
                    target === null || target === void 0 ? void 0 : target.blur();
                    this._taskBeingUpdated = null;
                    this._updatingTaskDate = false;
                }
            }
        };
        this.handleDateChange = (e) => {
            const value = e.target.value;
            if (value) {
                this._newTaskDueDate = new Date(value + 'T17:00');
            }
            else {
                this._newTaskDueDate = null;
            }
        };
        this.handleDateUpdate = (e) => {
            const task = this._taskBeingUpdated;
            if (task) {
                const value = e.target.value;
                if (value) {
                    this._newTaskDueDate = new Date(value + 'T17:00');
                }
                else {
                    this._newTaskDueDate = null;
                }
                if (task.dueDateTime && this._newTaskDueDate) {
                    this._isChangedDueDate = new Date(task.dueDateTime.dateTime) !== this._newTaskDueDate;
                }
                else if (task.dueDateTime || this._newTaskDueDate) {
                    this._isChangedDueDate = true;
                }
                else {
                    this._isChangedDueDate = false;
                }
            }
        };
        this._graph = null;
        this._newTaskDueDate = null;
        this._tasks = [];
        this.addEventListener('selectionChanged', this.handleSelectionChanged);
        this.addEventListener('blur', this.handleBlur);
    }
    /**
     * updates provider state
     *
     * @memberof MgtTodo
     */
    connectedCallback() {
        super.connectedCallback();
        window.addEventListener('darkmodechanged', this.onThemeChanged);
        // invoked to ensure we have the correct initial value for _isDarkMode
        this.onThemeChanged();
    }
    /**
     * removes updates on provider state
     *
     * @memberof MgtTodo
     */
    disconnectedCallback() {
        window.removeEventListener('darkmodechanged', this.onThemeChanged);
        super.disconnectedCallback();
    }
    /**
     * Render the list of todo tasks
     */
    renderTasks() {
        let tasks = this._tasks;
        if (tasks && this.taskFilter) {
            tasks = tasks.filter(task => this.taskFilter(task));
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const completedTasks = tasks.filter(task => task.status === 'completed');
        const taskTemplates = repeat(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        tasks.filter(task => task.status !== 'completed'), task => task.id, task => this.renderTask(task));
        const completedTaskTemplates = repeat(completedTasks
            .sort((a, b) => {
            return a.lastModifiedDateTime < b.lastModifiedDateTime ? -1 : 1;
        })
            .filter(task => task.status === 'completed'), task => task.id, task => this.renderTask(task));
        return html `
      ${taskTemplates}
      ${completedTaskTemplates}
    `;
    }
    /**
     * Render the generic picker or the task list displayName.
     *
     */
    renderPicker() {
        var _a, _b;
        if (this.targetId) {
            return html `<p>${(_a = this.currentList) === null || _a === void 0 ? void 0 : _a.displayName}</p>`;
        }
        else {
            return mgtHtml `
        <mgt-picker
          resource="me/todo/lists"
          scopes="tasks.read, tasks.readwrite"
          key-name="displayName"
          selected-value="${ifDefined((_b = this.currentList) === null || _b === void 0 ? void 0 : _b.displayName)}"
          placeholder="Select a task list">
        </mgt-picker>`;
        }
    }
    /**
     * Send a request the Graph to create a new todo task item
     *
     * @protected
     * @returns {Promise<void>}
     * @memberof MgtTodo
     */
    createNewTask() {
        return __awaiter(this, void 0, void 0, function* () {
            const listId = this.currentList.id;
            const taskData = {
                title: this._newTaskName
            };
            if (this._newTaskDueDate) {
                // eslint-disable-next-line @typescript-eslint/dot-notation
                taskData['dueDateTime'] = {
                    dateTime: new Date(this._newTaskDueDate).toLocaleDateString(),
                    timeZone: 'UTC'
                };
            }
            const task = yield createTodoTask(this._graph, listId, taskData);
            this._tasks.unshift(task);
        });
    }
    /**
     * Send a request the Graph to update a todo task item
     *
     * @protected
     * @returns {Promise<void>}
     * @memberof MgtTodo
     */
    updateTaskItem(task) {
        return __awaiter(this, void 0, void 0, function* () {
            const listId = this.currentList.id;
            let taskData = {};
            if (this._changedTaskName && this._changedTaskName !== task.title) {
                taskData = {
                    title: this._changedTaskName
                };
            }
            if (this._updatingTaskDate) {
                if (!this._isChangedDueDate) {
                    return;
                }
                if (this._newTaskDueDate) {
                    taskData.dueDateTime = {
                        dateTime: new Date(this._newTaskDueDate).toLocaleDateString(),
                        timeZone: 'UTC'
                    };
                }
                else if (this._isChangedDueDate && !this._newTaskDueDate) {
                    taskData.dueDateTime = null;
                }
                else {
                    taskData.dueDateTime = null;
                }
            }
            if (!Object.keys(taskData).length) {
                return;
            }
            const updatedTask = yield updateTodoTask(this._graph, listId, task.id, taskData);
            const taskIndex = this._tasks.findIndex(t => t.id === updatedTask.id);
            this._tasks[taskIndex] = updatedTask;
        });
    }
    handleTaskCheckClick(task) {
        this.handleTaskClick(task);
        if (!this.readOnly) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (task.status === 'completed') {
                void this.updateTaskStatus(task, 'notStarted');
            }
            else {
                void this.updateTaskStatus(task, 'completed');
            }
        }
    }
    handleTaskCheckKeydown(e, task) {
        if (e.key === 'Enter' && !this.readOnly) {
            this.handleTaskClick(task);
            if (task.status === 'completed') {
                void this.updateTaskStatus(task, 'notStarted');
            }
            else {
                void this.updateTaskStatus(task, 'completed');
            }
        }
    }
}
__decorate([
    state(),
    __metadata("design:type", Array)
], MgtTodo.prototype, "_tasks", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtTodo.prototype, "_taskBeingUpdated", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtTodo.prototype, "_updatingTaskDate", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtTodo.prototype, "_isChangedDueDate", void 0);
__decorate([
    state(),
    __metadata("design:type", Date)
], MgtTodo.prototype, "_newTaskDueDate", void 0);
__decorate([
    state(),
    __metadata("design:type", String)
], MgtTodo.prototype, "_newTaskName", void 0);
__decorate([
    state(),
    __metadata("design:type", String)
], MgtTodo.prototype, "_changedTaskName", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtTodo.prototype, "_isNewTaskBeingAdded", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtTodo.prototype, "_graph", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtTodo.prototype, "currentList", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtTodo.prototype, "_isDarkMode", void 0);
//# sourceMappingURL=mgt-todo.js.map