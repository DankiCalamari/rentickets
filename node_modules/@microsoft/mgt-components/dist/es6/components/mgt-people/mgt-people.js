/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { html } from 'lit';
import { property, state } from 'lit/decorators.js';
import { repeat } from 'lit/directives/repeat.js';
import { getPeople, getPeopleFromResource } from '../../graph/graph.people';
import { getUsersPresenceByPeople } from '../../graph/graph.presence';
import { findGroupMembers, getUsersForPeopleQueries, getUsersForUserIds } from '../../graph/graph.user';
import { Providers, ProviderState, MgtTemplatedTaskComponent, registerComponent, mgtHtml } from '@microsoft/mgt-element';
import '../../styles/style-helper';
import { personCardConverter } from './../PersonCardInteraction';
import { styles } from './mgt-people-css';
import { MgtPerson, registerMgtPersonComponent } from '../mgt-person/mgt-person';
/**
 * web component to display a group of people or contacts by using their photos or initials.
 *
 * @export
 * @class MgtPeople
 * @extends {MgtTemplatedTaskComponent}
 *
 * @cssprop --people-list-margin- {String} the margin around the list of people. Default is 8px 4px 8px 8px.
 * @cssprop --people-avatar-gap - {String} the gap between the people in the list. Default is 4px.
 * @cssprop --people-overflow-font-color - {Color} the color of the overflow text.
 * @cssprop --people-overflow-font-size - {String} the text color of the overflow text. Default is 12px.
 * @cssprop --people-overflow-font-weight - {String} the font weight of the overflow text. Default is 400.
 * @cssprop --people-person-avatar-size - {Length} the size of the avatar. Default is 24px.
 */
export const registerMgtPeopleComponent = () => {
    registerMgtPersonComponent();
    registerComponent('people', MgtPeople);
};
export class MgtPeople extends MgtTemplatedTaskComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    /**
     * Get the scopes required for people
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtPeople
     */
    static get requiredScopes() {
        return [
            ...new Set([
                'user.read.all',
                'people.read',
                'user.readbasic.all',
                'presence.read.all',
                'contacts.read',
                ...MgtPerson.requiredScopes
            ])
        ];
    }
    constructor() {
        super();
        /**
         * Sets how the person-card is invoked
         * Valid options are: 'none', 'hover', or 'click'
         * Set to 'none' to not show the card
         *
         * @type {PersonCardInteraction}
         * @memberof MgtPerson
         */
        this.personCardInteraction = 'hover';
        /**
         * Api version to use for request
         *
         * @type {string}
         * @memberof MgtPeople
         */
        this.version = 'v1.0';
        /**
         * The scopes to request
         *
         * @type {string[]}
         * @memberof MgtPeople
         */
        this.scopes = [];
        this._peoplePresence = {};
        this._arrowKeyLocation = -1;
        /**
         * Invoked on each update to perform rendering tasks. This method must return
         * a lit-html TemplateResult. Setting properties inside this method will *not*
         * trigger the element to update.
         */
        this.renderContent = () => {
            if (!this.people || this.people.length === 0) {
                return this.renderNoData();
            }
            return this.renderTemplate('default', { people: this.people, max: this.showMax }) || this.renderPeople();
        };
        /**
         * Render the loading state.
         *
         * @protected
         * @returns
         * @memberof MgtPeople
         */
        this.renderLoading = () => {
            return this.renderTemplate('loading', null) || html ``;
        };
        /**
         * Handles the keypresses on a keyboard for the listed people.
         *
         * @param event is a KeyboardEvent.
         */
        this.handleKeyDown = (event) => {
            const peopleContainer = this.shadowRoot.querySelector('.people-list');
            let person;
            const peopleElements = peopleContainer === null || peopleContainer === void 0 ? void 0 : peopleContainer.children;
            const keyName = event.key;
            // Default all tabindex values in li nodes to -1
            for (const element of peopleElements) {
                const el = element;
                el.removeAttribute('tabindex');
                person = el === null || el === void 0 ? void 0 : el.querySelector('mgt-person');
                person = person === null || person === void 0 ? void 0 : person.shadowRoot.querySelector('.person-root');
                person === null || person === void 0 ? void 0 : person.removeAttribute('tabindex');
                el.blur();
            }
            if (event.target === peopleContainer && (keyName === 'Tab' || keyName === 'Escape')) {
                this._arrowKeyLocation = -1;
                peopleContainer === null || peopleContainer === void 0 ? void 0 : peopleContainer.blur();
            }
            let childElementCount = peopleContainer === null || peopleContainer === void 0 ? void 0 : peopleContainer.childElementCount;
            let overflow = peopleContainer === null || peopleContainer === void 0 ? void 0 : peopleContainer.querySelector('.overflow');
            if (overflow) {
                // account for overflow
                overflow = overflow;
                overflow.removeAttribute('tabindex');
                childElementCount--;
            }
            if (keyName === 'ArrowRight') {
                this._arrowKeyLocation = (this._arrowKeyLocation + 1 + childElementCount) % childElementCount;
            }
            else if (keyName === 'ArrowLeft') {
                this._arrowKeyLocation = (this._arrowKeyLocation - 1 + childElementCount) % childElementCount;
            }
            else if (['Enter', 'space', ' '].includes(keyName)) {
                if (this.personCardInteraction !== 'none') {
                    const personEl = peopleElements[this._arrowKeyLocation];
                    const mgtPerson = personEl.querySelector('mgt-person');
                    if (mgtPerson) {
                        mgtPerson.showPersonCard();
                    }
                }
            }
            if (this._arrowKeyLocation > -1) {
                person = peopleElements[this._arrowKeyLocation];
                person.setAttribute('tabindex', '0');
                person.focus();
                person = person.querySelector('.people-person');
                person === null || person === void 0 ? void 0 : person.shadowRoot.querySelector('.person-root').setAttribute('tabindex', '0');
            }
        };
        this.showMax = 3;
    }
    /**
     * Clears the state of the component
     *
     * @protected
     * @memberof MgtPeople
     */
    clearState() {
        this.people = null;
    }
    args() {
        return [
            this.providerState,
            this.groupId,
            this.userIds,
            this.peopleQueries,
            this.showMax,
            this.resource,
            this.version,
            this.fallbackDetails
        ];
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        this.checkPeopleListAndFireEvent();
    }
    checkPeopleListAndFireEvent() {
        var _a;
        const peopleList = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.people-list');
        if ((peopleList === null || peopleList === void 0 ? void 0 : peopleList.childElementCount) > 0) {
            this.fireCustomEvent('people-rendered');
        }
    }
    /**
     * Render the list of people.
     *
     * @protected
     * @param {*} people
     * @returns {TemplateResult}
     * @memberof MgtPeople
     */
    renderPeople() {
        const maxPeople = this.people.slice(0, this.showMax).filter(pple => pple);
        return html `
      <ul
        tabindex="0"
        class="people-list"
        aria-label="people"
        @keydown=${this.handleKeyDown}>
        ${repeat(maxPeople, p => (p.id ? p.id : p.displayName), p => html `
            <li class="people-person">
              ${this.renderPerson(p)}
            </li>
          `)}
        ${this.people.length > this.showMax ? this.renderOverflow() : null}
      </ul>
    `;
    }
    /**
     * Render the overflow content to represent any extra people, beyond the max.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeople
     */
    renderOverflow() {
        const extra = this.people.length - this.showMax;
        return (this.renderTemplate('overflow', {
            extra,
            max: this.showMax,
            people: this.people
        }) ||
            html `
        <li aria-label="and ${extra} more attendees" class="overflow"><span>+${extra}</span></li>
      `);
    }
    /**
     * Render an individual person.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeople
     */
    renderPerson(person) {
        let personPresence = {
            // set up default presence
            activity: 'Offline',
            availability: 'Offline',
            id: null
        };
        if (this.showPresence && this._peoplePresence) {
            personPresence = this._peoplePresence[person.id];
        }
        const avatarSize = 'small';
        return (this.renderTemplate('person', { person }, person.id) ||
            // set image to @ to flag the mgt-person component to
            // query the image from the graph
            mgtHtml `
        <mgt-person
          .personDetails=${person}
          .fetchImage=${true}
          .avatarSize=${avatarSize}
          .personCardInteraction=${this.personCardInteraction}
          .showPresence=${this.showPresence}
          .personPresence=${personPresence}
          .usage=${'people'}
        ></mgt-person>
      `);
    }
    /**
     * render the no data state.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeople
     */
    renderNoData() {
        return this.renderTemplate('no-data', null) || html ``;
    }
    /**
     * load state into the component.
     *
     * @protected
     * @returns
     * @memberof MgtPeople
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.people) {
                const provider = Providers.globalProvider;
                if (provider && provider.state === ProviderState.SignedIn) {
                    const graph = provider.graph.forComponent(this);
                    // populate people
                    if (this.groupId) {
                        this.people = yield findGroupMembers(graph, null, this.groupId, this.showMax, 'person');
                    }
                    else if (this.userIds) {
                        this.people = yield getUsersForUserIds(graph, this.userIds, '', '', this.fallbackDetails);
                    }
                    else if (this.peopleQueries) {
                        this.people = yield getUsersForPeopleQueries(graph, this.peopleQueries, this.fallbackDetails);
                    }
                    else if (this.resource) {
                        this.people = yield getPeopleFromResource(graph, this.version, this.resource, this.scopes);
                    }
                    else {
                        this.people = yield getPeople(graph);
                    }
                    // populate presence for people
                    if (this.showPresence) {
                        this._peoplePresence = yield getUsersPresenceByPeople(graph, this.people);
                    }
                    else {
                        this._peoplePresence = null;
                    }
                }
            }
        });
    }
}
__decorate([
    property({
        attribute: 'group-id',
        type: String
    }),
    __metadata("design:type", String)
], MgtPeople.prototype, "groupId", void 0);
__decorate([
    property({
        attribute: 'user-ids',
        converter: (value, _type) => {
            return value.split(',').map(v => v.trim());
        }
    }),
    __metadata("design:type", Array)
], MgtPeople.prototype, "userIds", void 0);
__decorate([
    property({
        attribute: 'people',
        type: Object
    }),
    __metadata("design:type", Array)
], MgtPeople.prototype, "people", void 0);
__decorate([
    property({
        attribute: 'people-queries',
        converter: (value, _type) => {
            return value.split(',').map(v => v.trim());
        }
    }),
    __metadata("design:type", Array)
], MgtPeople.prototype, "peopleQueries", void 0);
__decorate([
    property({
        attribute: 'show-max',
        type: Number
    }),
    __metadata("design:type", Number)
], MgtPeople.prototype, "showMax", void 0);
__decorate([
    property({
        attribute: 'show-presence',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPeople.prototype, "showPresence", void 0);
__decorate([
    property({
        attribute: 'person-card',
        converter: (value, _type) => personCardConverter(value, 'hover')
    }),
    __metadata("design:type", String)
], MgtPeople.prototype, "personCardInteraction", void 0);
__decorate([
    property({
        attribute: 'resource',
        type: String
    }),
    __metadata("design:type", String)
], MgtPeople.prototype, "resource", void 0);
__decorate([
    property({
        attribute: 'version',
        type: String
    }),
    __metadata("design:type", Object)
], MgtPeople.prototype, "version", void 0);
__decorate([
    property({
        attribute: 'scopes',
        converter: value => {
            return value ? value.toLowerCase().split(',') : null;
        },
        reflect: true
    }),
    __metadata("design:type", Array)
], MgtPeople.prototype, "scopes", void 0);
__decorate([
    property({
        attribute: 'fallback-details',
        type: Array
    }),
    __metadata("design:type", Array)
], MgtPeople.prototype, "fallbackDetails", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtPeople.prototype, "_arrowKeyLocation", void 0);
//# sourceMappingURL=mgt-people.js.map