{"version":3,"file":"IProvider.tests.js","sourceRoot":"src/","sources":["providers/IProvider.tests.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;;;;;;;;AAGH,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,MAAM,EAAE,MAAM,kBAAkB,CAAC;AAE1C,QAAQ,CAAC,uCAAuC,EAAE,GAAG,EAAE;IACrD,IAAI,CAAY,CAAC;IACjB,UAAU,CAAC,GAAG,EAAE;QACd,CAAC,GAAG,IAAI,cAAc,CACpB,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,YAAY,CAAC,EACnC,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,EACvB,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,CACxB,CAAC;QACF,CAAC,CAAC,cAAc,GAAG,CAAC,WAAW,EAAE,gBAAgB,EAAE,eAAe,CAAC,CAAC;IACtE,CAAC,CAAC,CAAC;IACH,EAAE,CAAC,iEAAiE,EAAE,GAAS,EAAE;QAC/E,MAAM,MAAM,GAAG,CAAC,CAAC,qBAAqB,CAAC,CAAC,sBAAsB,EAAE,gBAAgB,CAAC,CAAC,CAAC;QACnF,MAAM,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAClC,CAAC,CAAA,CAAC,CAAC;IACH,EAAE,CAAC,qGAAqG,EAAE,GAAS,EAAE;QACnH,CAAC,CAAC,cAAc,GAAG,CAAC,WAAW,EAAE,gBAAgB,EAAE,eAAe,CAAC,CAAC;QACpE,MAAM,MAAM,GAAG,CAAC,CAAC,qBAAqB,CAAC,CAAC,sBAAsB,EAAE,gBAAgB,CAAC,CAAC,CAAC;QACnF,MAAM,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAClC,CAAC,CAAA,CAAC,CAAC;IACH,EAAE,CAAC,qGAAqG,EAAE,GAAS,EAAE;QACnH,MAAM,MAAM,GAAG,CAAC,CAAC,qBAAqB,CAAC,CAAC,sBAAsB,EAAE,gBAAgB,CAAC,CAAC,CAAC;QACnF,MAAM,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAClC,CAAC,CAAA,CAAC,CAAC;IACH,EAAE,CAAC,mFAAmF,EAAE,GAAS,EAAE;QACjG,MAAM,MAAM,GAAG,CAAC,CAAC,qBAAqB,CAAC,CAAC,sBAAsB,EAAE,qBAAqB,CAAC,CAAC,CAAC;QACxF,MAAM,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC;IACxD,CAAC,CAAA,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\nimport { IProvider } from './IProvider';\nimport { SimpleProvider } from './SimpleProvider';\nimport { expect } from '@open-wc/testing';\n\ndescribe('IProvider.needsAdditionalScopes tests', () => {\n  let p: IProvider;\n  beforeEach(() => {\n    p = new SimpleProvider(\n      () => Promise.resolve('fake-token'),\n      () => Promise.resolve(),\n      () => Promise.resolve()\n    );\n    p.approvedScopes = ['user.read', 'group.read.all', 'presence.read'];\n  });\n  it('should provide an empty array when one scope is already present', async () => {\n    const result = p.needsAdditionalScopes(['groupmember.read.all', 'group.read.all']);\n    await expect(result).to.eql([]);\n  });\n  it('should provide an empty array when one scope is already present ignoring case of scopes in provider', async () => {\n    p.approvedScopes = ['user.read', 'Group.Read.All', 'presence.read'];\n    const result = p.needsAdditionalScopes(['groupmember.read.all', 'group.read.all']);\n    await expect(result).to.eql([]);\n  });\n  it('should provide an empty array when one scope is already present ignoring case of scopes in provider', async () => {\n    const result = p.needsAdditionalScopes(['groupmember.read.all', 'Group.Read.All']);\n    await expect(result).to.eql([]);\n  });\n  it('should provide an the first element in the passed array where there is no overlap', async () => {\n    const result = p.needsAdditionalScopes(['groupmember.read.all', 'group.readwrite.all']);\n    await expect(result).to.eql(['groupmember.read.all']);\n  });\n});\n"]}