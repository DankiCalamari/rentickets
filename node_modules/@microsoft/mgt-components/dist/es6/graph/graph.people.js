/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes, CacheService } from '@microsoft/mgt-element';
import { extractEmailAddress } from '../utils/Utils';
import { schemas } from './cacheStores';
const personTypes = ['any', 'person', 'group'];
export const isPersonType = (value) => typeof value === 'string' && personTypes.includes(value);
export const personTypeConverter = (value, defaultValue = 'any') => isPersonType(value) ? value : defaultValue;
const userTypes = ['any', 'user', 'contact'];
export const isUserType = (value) => {
    return typeof value === 'string' && userTypes.includes(value);
};
export const userTypeConverter = (value, defaultValue = 'any') => isUserType(value) ? value : defaultValue;
/**
 * Defines the expiration time
 */
const getPeopleInvalidationTime = () => {
    return CacheService.config.people.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
};
/**
 * Whether the people store is enabled
 */
const getIsPeopleCacheEnabled = () => CacheService.config.people.isEnabled && CacheService.config.isEnabled;
const validPeopleQueryScopes = ['People.Read', 'People.Read.All'];
const validContactQueryScopes = ['Contacts.Read', 'Contacts.ReadWrite'];
/**
 * async promise, returns all Graph people who are most relevant contacts to the signed in user.
 *
 * @param {IGraph} graph
 * @param {string} query
 * @param {number} [top=10] - number of people to return
 * @param {UserType} [personType='any'] - the type of person to search for
 * @returns {(Promise<Person[]>)}
 */
export const findPeople = (graph, query, top = 10, userType = 'any', filters = '') => __awaiter(void 0, void 0, void 0, function* () {
    const cacheKey = `${query}:${top}:${userType}`;
    let cache;
    if (getIsPeopleCacheEnabled()) {
        const people = schemas.people;
        const peopleQuery = schemas.people.stores.peopleQuery;
        cache = CacheService.getCache(people, peopleQuery);
        const result = getIsPeopleCacheEnabled() ? yield cache.getValue(cacheKey) : null;
        if (result && getPeopleInvalidationTime() > Date.now() - result.timeCached) {
            return result.results.map(peopleStr => JSON.parse(peopleStr));
        }
    }
    let filter = "personType/class eq 'Person'";
    if (userType !== 'any') {
        if (userType === 'user') {
            filter += "and personType/subclass eq 'OrganizationUser'";
        }
        else {
            filter += "and (personType/subclass eq 'ImplicitContact' or personType/subclass eq 'PersonalContact')";
        }
    }
    if (filters !== '') {
        // Adding the default people filters to the search filters
        filter += ` and  ${filters}`;
    }
    let graphResult;
    try {
        let graphRequest = graph
            .api('/me/people')
            .search('"' + query + '"')
            .top(top)
            .filter(filter)
            .middlewareOptions(prepScopes(validPeopleQueryScopes));
        if (userType !== 'contact') {
            // for any type other than Contact, user a wider search
            graphRequest = graphRequest.header('X-PeopleQuery-QuerySources', 'Mailbox,Directory');
        }
        graphResult = (yield graphRequest.get());
        if (getIsPeopleCacheEnabled() && graphResult) {
            const item = { maxResults: top, results: null };
            item.results = graphResult.value.map(personStr => JSON.stringify(personStr));
            yield cache.putValue(cacheKey, item);
        }
    }
    catch (error) {
        // intentionally empty
    }
    return graphResult === null || graphResult === void 0 ? void 0 : graphResult.value;
});
/**
 * async promise to the Graph for People, by default, it will request the most frequent contacts for the signed in user.
 *
 * @returns {(Promise<Person[]>)}
 * @memberof Graph
 */
export const getPeople = (graph, userType = 'any', peopleFilters = '', top = 10) => __awaiter(void 0, void 0, void 0, function* () {
    let cache;
    const cacheKey = `${peopleFilters ? peopleFilters : `*:${userType}`}:${top}`;
    if (getIsPeopleCacheEnabled()) {
        cache = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
        const cacheRes = yield cache.getValue(cacheKey);
        if (cacheRes && getPeopleInvalidationTime() > Date.now() - cacheRes.timeCached) {
            return cacheRes.results.map(ppl => JSON.parse(ppl));
        }
    }
    const uri = '/me/people';
    let filter = "personType/class eq 'Person'";
    if (userType !== 'any') {
        if (userType === 'user') {
            filter += "and personType/subclass eq 'OrganizationUser'";
        }
        else {
            filter += "and (personType/subclass eq 'ImplicitContact' or personType/subclass eq 'PersonalContact')";
        }
    }
    if (peopleFilters) {
        filter += ` and ${peopleFilters}`;
    }
    let people;
    try {
        let graphRequest = graph.api(uri).middlewareOptions(prepScopes(validPeopleQueryScopes)).top(top).filter(filter);
        if (userType !== 'contact') {
            // for any type other than Contact, user a wider search
            graphRequest = graphRequest.header('X-PeopleQuery-QuerySources', 'Mailbox,Directory');
        }
        people = (yield graphRequest.get());
        if (getIsPeopleCacheEnabled() && people) {
            yield cache.putValue(cacheKey, { maxResults: 10, results: people.value.map(ppl => JSON.stringify(ppl)) });
        }
    }
    catch (_) {
        // no-op
    }
    return people ? people.value : null;
});
/**
 * Attempts to extract the email from the IDynamicPerson properties.
 *
 * @param {IDynamicperson} entity
 */
export const getEmailFromGraphEntity = (entity) => {
    var _a, _b;
    const person = entity;
    const user = entity;
    const contact = entity;
    if (user === null || user === void 0 ? void 0 : user.mail) {
        return extractEmailAddress(user.mail);
    }
    else if ((_a = person.scoredEmailAddresses) === null || _a === void 0 ? void 0 : _a.length) {
        return extractEmailAddress(person.scoredEmailAddresses[0].address);
    }
    else if ((_b = contact.emailAddresses) === null || _b === void 0 ? void 0 : _b.length) {
        return extractEmailAddress(contact.emailAddresses[0].address);
    }
    return null;
};
/**
 * async promise, returns a Graph contact associated with the email provided
 *
 * @param {string} email
 * @returns {(Promise<Contact[]>)}
 * @memberof Graph
 */
export const findContactsByEmail = (graph, email) => __awaiter(void 0, void 0, void 0, function* () {
    let cache;
    if (getIsPeopleCacheEnabled()) {
        cache = CacheService.getCache(schemas.people, schemas.people.stores.contacts);
        const contact = yield cache.getValue(email);
        if (contact && getPeopleInvalidationTime() > Date.now() - contact.timeCached) {
            return JSON.parse(contact.person);
        }
    }
    const encodedEmail = `${email.replace(/#/g, '%2523')}`;
    const result = (yield graph
        .api('/me/contacts')
        .filter(`emailAddresses/any(a:a/address eq '${encodedEmail}')`)
        .middlewareOptions(prepScopes(validContactQueryScopes))
        .get());
    if (getIsPeopleCacheEnabled() && result) {
        yield cache.putValue(email, { person: JSON.stringify(result.value) });
    }
    return result ? result.value : null;
});
/**
 * async promise, returns Graph people matching the Graph query specified
 * in the resource param
 *
 * @param {IGraph} graph - the graph instance to use for making requests
 * @param {string} version - the graph version url segment to use when making requests
 * @param {string} resource - the resource segment of the graph url to be requested
 * @param {string[]} scopes - an array of scopes that are required to make the underlying graph request,
 *  if any scope provided is not currently consented then the user will be prompted for consent prior to
 *  making the graph request to load data.
 * @returns {(Promise<Person[]>)}
 * @memberof Graph
 */
export const getPeopleFromResource = (graph, version, resource, scopes) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    let cache;
    const key = `${version}${resource}`;
    if (getIsPeopleCacheEnabled()) {
        cache = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
        const result = yield cache.getValue(key);
        if (result && getPeopleInvalidationTime() > Date.now() - result.timeCached) {
            return result.results.map(peopleStr => JSON.parse(peopleStr));
        }
    }
    let request = graph.api(resource).version(version);
    if (scopes === null || scopes === void 0 ? void 0 : scopes.length) {
        request = request.middlewareOptions(prepScopes(scopes));
    }
    let response = (yield request.get());
    // get more pages if there are available
    if (response && Array.isArray(response.value) && response['@odata.nextLink']) {
        let page = response;
        while (page === null || page === void 0 ? void 0 : page['@odata.nextLink']) {
            const nextLink = page['@odata.nextLink'];
            const nextResource = nextLink.split(version)[1];
            page = (yield graph.api(nextResource).version(version).get());
            if ((_a = page === null || page === void 0 ? void 0 : page.value) === null || _a === void 0 ? void 0 : _a.length) {
                page.value = response.value.concat(page.value);
                response = page;
            }
        }
    }
    if (getIsPeopleCacheEnabled() && response) {
        const item = { results: null };
        if (Array.isArray(response.value)) {
            item.results = response.value.map(personStr => JSON.stringify(personStr));
        }
        else {
            item.results = [JSON.stringify(response)];
        }
        yield cache.putValue(key, item);
    }
    return response === null || response === void 0 ? void 0 : response.value;
});
//# sourceMappingURL=graph.people.js.map