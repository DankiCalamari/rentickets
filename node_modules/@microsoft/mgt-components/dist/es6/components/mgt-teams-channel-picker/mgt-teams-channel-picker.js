/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { html } from 'lit';
import { state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { TaskStatus } from '@lit/task';
import { Providers, ProviderState, MgtTemplatedTaskComponent, mgtHtml } from '@microsoft/mgt-element';
import '../../styles/style-helper';
import { getSvg, SvgIcon } from '../../utils/SvgHelper';
import { debounce } from '../../utils/Utils';
import { styles } from './mgt-teams-channel-picker-css';
import { getAllMyTeams, getChannelsForTeams, getTeamsPhotosForPhotoIds } from './mgt-teams-channel-picker.graph';
import { strings } from './strings';
import { repeat } from 'lit/directives/repeat.js';
import { registerFluentComponents } from '../../utils/FluentComponents';
import { fluentBreadcrumb, fluentBreadcrumbItem, fluentTreeView, fluentTreeItem, fluentCard, fluentTextField } from '@fluentui/web-components';
import { registerComponent } from '@microsoft/mgt-element';
import { registerMgtSpinnerComponent } from '../sub-components/mgt-spinner/mgt-spinner';
export const registerMgtTeamsChannelPickerComponent = () => {
    registerFluentComponents(fluentBreadcrumb, fluentBreadcrumbItem, fluentCard, fluentTreeView, fluentTreeItem, fluentTextField);
    registerMgtSpinnerComponent();
    registerComponent('teams-channel-picker', MgtTeamsChannelPicker);
};
/**
 * Web component used to select channels from a User's Microsoft Teams profile
 *
 *
 * @class MgtTeamsChannelPicker
 * @extends {MgtTemplatedTaskComponent}
 *
 * @fires {CustomEvent<SelectedChannel | null>} selectionChanged - Fired when the selection changes
 *
 * @cssprop --channel-picker-input-border-color - {Color} Input border color
 * @cssprop --channel-picker-input-background-color - {Color} Input section background color
 * @cssprop --channel-picker-input-background-color-hover - {Color} Input background hover color
 * @cssprop --channel-picker-input-background-color-focus - {Color} Input background focus color
 *
 * @cssprop --channel-picker-dropdown-background-color - {Color} Background color of dropdown area
 * @cssprop --channel-picker-dropdown-item-text-color - {Color} Text color of the dropdown text.
 * @cssprop --channel-picker-dropdown-item-background-color-hover - {Color} Background color of channel or team during hover
 * @cssprop --channel-picker-dropdown-item-text-color-selected - {Color} Text color of channel or team during after selection
 *
 * @cssprop --channel-picker-arrow-fill - {Color} Color of arrow svg
 * @cssprop --channel-picker-input-placeholder-text-color - {Color} Color of placeholder text
 * @cssprop --channel-picker-input-placeholder-text-color-focus - {Color} Color of placeholder text during focus state
 * @cssprop --channel-picker-input-placeholder-text-color-hover - {Color} Color of placeholder text during hover state
 *
 * @cssprop --channel-picker-search-icon-color - {Color} the search icon color.
 * @cssprop --channel-picker-down-chevron-color - {Color} the down chevron icon color.
 * @cssprop --channel-picker-up-chevron-color - {Color} the up chevron icon color.
 * @cssprop --channel-picker-close-icon-color - {Color} the close icon color.
 *
 */
export class MgtTeamsChannelPicker extends MgtTemplatedTaskComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * user the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    /**
     * Strings for localization
     *
     * @readonly
     * @protected
     * @memberof MgtTeamsChannelPicker
     */
    get strings() {
        return strings;
    }
    /**
     * Gets Selected item to be used
     *
     * @readonly
     * @type {SelectedChannel}
     * @memberof MgtTeamsChannelPicker
     */
    get selectedItem() {
        if (this._selectedItemState) {
            return { channel: this._selectedItemState.item, team: this._selectedItemState.parent.item };
        }
        else {
            return null;
        }
    }
    /**
     * Get the scopes required for teams channel picker
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtTeamsChannelPicker
     */
    static get requiredScopes() {
        return ['team.readbasic.all', 'channel.readbasic.all'];
    }
    set items(value) {
        if (this._items === value) {
            return;
        }
        this._items = value;
        this._treeViewState = value ? this.generateTreeViewState(value) : [];
        this.resetFocusState();
    }
    get items() {
        return this._items;
    }
    get _inputWrapper() {
        return this.renderRoot.querySelector('fluent-text-field');
    }
    // User input in search
    get _input() {
        const wrapper = this._inputWrapper;
        const input = wrapper === null || wrapper === void 0 ? void 0 : wrapper.shadowRoot.querySelector('input');
        return input;
    }
    constructor() {
        super();
        this.teamsPhotos = {};
        this._inputValue = '';
        this._treeViewState = [];
        this._focusList = [];
        /**
         * Called from the base class while the _task is in a pending state
         * This calls to the renderContent method as the loading indicator is nested inside the dropdown
         * This ensures that the component shows a control immediately and only shows a loading indicator
         * if the user interacts with the component while the _task is pending.
         */
        this.renderLoading = () => this.renderContent();
        /**
         * Invoked by the render method when the _task has been completed
         *
         * @returns
         * @memberof MgtTeamsChannelPicker
         */
        this.renderContent = () => {
            var _a;
            const dropdownClasses = {
                dropdown: true,
                visible: this._isDropdownVisible
            };
            return (this.renderTemplate('default', { teams: (_a = this.items) !== null && _a !== void 0 ? _a : [] }) ||
                html `
        <div class="container" @blur=${this.lostFocus}>
          <fluent-text-field
            autocomplete="off"
            appearance="outline"
            id="teams-channel-picker-input"
            role="combobox"
            placeholder="${this._selectedItemState ? '' : this.strings.inputPlaceholderText} "
            aria-label=${this.strings.inputPlaceholderText}
            aria-expanded="${this._isDropdownVisible}"
            label="teams-channel-picker-input"
            @focus=${this.handleFocus}
            @keyup=${this.handleInputChanged}
            @click=${this.handleInputClick}
            @keydown=${this.handleInputKeydown}
          >
            <div tabindex="0" slot="start" style="width: max-content;" @keydown=${this.handleStartSlotKeydown}>${this.renderSelected()}</div>
            <div tabindex="0" slot="end" @keydown=${this.handleChevronKeydown}>${this.renderChevrons()}${this.renderCloseButton()}</div>
          </fluent-text-field>
          <fluent-card
            class=${classMap(dropdownClasses)}
          >
            ${this.renderDropdown()}
          </fluent-card>
        </div>`);
        };
        /**
         * Handles clicks on the input section.
         *
         * @param e {UIEvent}
         */
        this.handleInputClick = (e) => {
            e.stopPropagation();
            this.gainedFocus();
        };
        this.handleInputKeydown = (e) => {
            const keyName = e.key;
            if (['ArrowDown', 'Enter'].includes(keyName)) {
                if (!this._isDropdownVisible) {
                    this.gainedFocus();
                }
                else {
                    // focus on the first item on the list. Ideally, focus on the selected.
                    const firstTreeItem = this.renderRoot.querySelector('fluent-tree-item');
                    firstTreeItem.focus();
                }
            }
            else if (keyName === 'Escape') {
                this.lostFocus();
            }
            else if (keyName === 'Tab') {
                this.blurPicker();
            }
        };
        /**
         * Handles clicks on the close button after selecting a channel.
         *
         * @param e {UIEvent}
         */
        this.onClickCloseButton = () => {
            this.removeSelectedChannel(null);
        };
        /**
         * Handles keypresses on the close button.
         *
         * @param e {KeyboardEvent}
         */
        this.onKeydownCloseButton = (e) => {
            if (e.key === 'Enter')
                this.removeSelectedChannel(null);
        };
        /**
         * Renders an error message when no channel or teams match the query
         *
         * @protected
         * @returns
         * @memberof MgtTeamsChannelPicker
         */
        this.renderError = () => {
            const template = this.renderTemplate('error', null, 'error');
            return (template ||
                html `
        <div class="message-parent">
          <div
            label="search-error-text"
            aria-live="polite"
            aria-relevant="all"
            aria-atomic="true"
            class="search-error-text"
          >
            ${this.strings.noResultsFound}
          </div>
        </div>
      `);
        };
        /**
         * Renders loading spinner while channels are fetched from the Graph
         *
         * @protected
         * @returns
         * @memberof MgtTeamsChannelPicker
         */
        this.renderLoadingIndicator = () => {
            const template = this.renderTemplate('loading', null, 'loading');
            return (template ||
                mgtHtml `
        <div class="message-parent">
          <mgt-spinner></mgt-spinner>
          <div label="loading-text" aria-label="loading" class="loading-text">
            ${this.strings.loadingMessage}
          </div>
        </div>
      `);
        };
        this.onKeydownTreeView = (e) => {
            const keyName = e.key;
            if (keyName === 'Escape') {
                this.lostFocus();
            }
        };
        this.handleTeamTreeItemClick = (event) => {
            event.preventDefault();
            event.stopImmediatePropagation();
            const element = event.target;
            if (element) {
                const expanded = element.getAttribute('expanded');
                if (expanded) {
                    element.removeAttribute('expanded');
                }
                else {
                    element.setAttribute('expanded', 'true');
                }
                element.removeAttribute('selected');
                const hasId = element.getAttribute('id');
                if (hasId) {
                    element.setAttribute('selected', 'true');
                }
            }
        };
        this.handleInputChanged = (e) => {
            const target = e.target;
            if (this._inputValue !== (target === null || target === void 0 ? void 0 : target.value)) {
                this._inputValue = target === null || target === void 0 ? void 0 : target.value;
            }
            else {
                return;
            }
            // shows list
            if (e.key !== 'Tab' && e.key !== 'Enter' && e.key !== 'Escape') {
                this.gainedFocus();
            }
            if (!this.debouncedSearch) {
                this.debouncedSearch = debounce(() => {
                    this.filterList();
                }, 400);
            }
            this.debouncedSearch();
        };
        this.loadTeamsIfNotLoaded = () => {
            if (!this.items && this._task.status !== TaskStatus.PENDING) {
                void this._task.run();
            }
        };
        this.handleWindowClick = (e) => {
            if (e.target !== this) {
                this.lostFocus();
            }
        };
        this.gainedFocus = () => {
            const input = this._input;
            if (input) {
                input.focus();
            }
            this._isDropdownVisible = true;
            this.toggleChevron();
            this.resetFocusState();
            this.requestUpdate();
        };
        this.lostFocus = () => {
            this._inputValue = '';
            if (this._input) {
                this._input.value = this._inputValue;
                this._input.textContent = '';
            }
            const wrapper = this._inputWrapper;
            if (wrapper) {
                wrapper.value = '';
                wrapper.blur();
            }
            this._isDropdownVisible = false;
            this.filterList();
            this.toggleChevron();
            this.requestUpdate();
            if (this._selectedItemState !== undefined) {
                this.showCloseIcon();
            }
        };
        this.handleFocus = () => {
            this.gainedFocus();
        };
        this.handleUpChevronClick = (e) => {
            e.stopPropagation();
            this.lostFocus();
        };
        this.handleChevronKeydown = (e) => {
            if (e.key === 'Tab') {
                this.blurPicker();
            }
        };
        this.handleStartSlotKeydown = (e) => {
            if (e.key === 'Tab' && e.shiftKey) {
                this.blurPicker();
            }
        };
        this.blurPicker = () => {
            const wrapper = this._inputWrapper;
            const input = this._input;
            wrapper === null || wrapper === void 0 ? void 0 : wrapper.blur();
            input === null || input === void 0 ? void 0 : input.blur();
        };
        this._inputValue = '';
        this._treeViewState = [];
        this._focusList = [];
        this._isDropdownVisible = false;
    }
    /**
     * Invoked each time the custom element is appended into a document-connected element
     *
     * @memberof MgtTeamsChannelPicker
     */
    connectedCallback() {
        super.connectedCallback();
        window.addEventListener('click', this.handleWindowClick);
        this.addEventListener('focus', this.loadTeamsIfNotLoaded);
        this.addEventListener('mouseover', this.loadTeamsIfNotLoaded);
        this.addEventListener('blur', this.lostFocus);
        const ownerDocument = this.renderRoot.ownerDocument;
        if (ownerDocument) {
            ownerDocument.documentElement.setAttribute('dir', this.direction);
        }
    }
    /**
     * Invoked each time the custom element is disconnected from the document's DOM
     *
     * @memberof MgtTeamsChannelPicker
     */
    disconnectedCallback() {
        window.removeEventListener('click', this.handleWindowClick);
        this.removeEventListener('focus', this.loadTeamsIfNotLoaded);
        this.removeEventListener('mouseover', this.loadTeamsIfNotLoaded);
        this.removeEventListener('blur', this.lostFocus);
        super.disconnectedCallback();
    }
    args() {
        return [];
    }
    /**
     * selects a channel by looking up the id in the Graph
     *
     * @param {string} channelId MicrosoftGraph.Channel.id
     * @returns {Promise<return>} A promise that will resolve to true if channel was selected
     * @memberof MgtTeamsChannelPicker
     */
    selectChannelById(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            if (provider && provider.state === ProviderState.SignedIn) {
                // since the component normally handles loading on hover, forces the load for items
                if (!this.items) {
                    yield this._task.run();
                }
                for (const item of this._treeViewState) {
                    for (const channel of item.channels) {
                        if (channel.item.id === channelId) {
                            item.isExpanded = true;
                            this.selectChannel(channel);
                            this.markSelectedChannelInDropdown(channelId);
                            return true;
                        }
                    }
                }
            }
            return false;
        });
    }
    /**
     * Marks a channel selected by ID as selected in the dropdown menu.
     * It ensures the parent team is set to as expanded to show the channel.
     *
     * @param channelId ID string of the selected channel
     */
    markSelectedChannelInDropdown(channelId) {
        const treeItem = this.renderRoot.querySelector(`[id='${channelId}']`);
        if (treeItem) {
            treeItem.setAttribute('selected', 'true');
            if (treeItem.parentElement) {
                treeItem.parentElement.setAttribute('expanded', 'true');
            }
        }
    }
    /**
     * Renders selected channel
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderSelected() {
        var _a, _b, _c, _d, _e, _f;
        if (!this._selectedItemState) {
            return this.renderSearchIcon();
        }
        let icon;
        if (this._selectedItemState.parent.channels) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment
            const src = (_a = this.teamsPhotos[this._selectedItemState.parent.item.id]) === null || _a === void 0 ? void 0 : _a.photo;
            icon = html `<img
        class="team-photo"
        alt="${this._selectedItemState.parent.item.displayName}"
        role="img"
        src=${src} />`;
        }
        const parentName = (_d = (_c = (_b = this._selectedItemState) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.item) === null || _d === void 0 ? void 0 : _d.displayName.trim();
        const channelName = (_f = (_e = this._selectedItemState) === null || _e === void 0 ? void 0 : _e.item) === null || _f === void 0 ? void 0 : _f.displayName.trim();
        return html `
      <fluent-breadcrumb title=${this._selectedItemState.item.displayName}>
        <fluent-breadcrumb-item>
          <span slot="start">${icon}</span>
          <span class="team-parent-name">${parentName}</span>
          <span slot="separator" class="arrow">${getSvg(SvgIcon.TeamSeparator, '#000000')}</span>
        </fluent-breadcrumb-item>
        <fluent-breadcrumb-item>${channelName}</fluent-breadcrumb-item>
      </fluent-breadcrumb>`;
    }
    /**
     * Clears the state of the component
     *
     * @protected
     * @memberof MgtTeamsChannelPicker
     */
    clearState() {
        this._inputValue = '';
        this._treeViewState = [];
        this._focusList = [];
        this._isDropdownVisible = false;
    }
    /**
     * Renders search icon
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderSearchIcon() {
        return html `
      <div class="search-icon" @keydown=${this.handleStartSlotKeydown}>
        ${getSvg(SvgIcon.Search, '#252424')}
      </div>
    `;
    }
    /**
     * Renders close button
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderCloseButton() {
        return html `
      <fluent-button
        appearance="stealth"
        class="close-icon"
        style="display:none"
        aria-label=${this.strings.closeButtonAriaLabel}
        @click=${this.onClickCloseButton}
        @keydown=${this.onKeydownCloseButton}>
        <svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M0.0885911 0.215694L0.146447 0.146447C0.320013 -0.0271197 0.589437 -0.046405 0.784306 0.0885911L0.853553 0.146447L4 3.293L7.14645 0.146447C7.34171 -0.0488154 7.65829 -0.0488154 7.85355 0.146447C8.04882 0.341709 8.04882 0.658291 7.85355 0.853553L4.707 4L7.85355 7.14645C8.02712 7.32001 8.0464 7.58944 7.91141 7.78431L7.85355 7.85355C7.67999 8.02712 7.41056 8.0464 7.21569 7.91141L7.14645 7.85355L4 4.707L0.853553 7.85355C0.658291 8.04882 0.341709 8.04882 0.146447 7.85355C-0.0488154 7.65829 -0.0488154 7.34171 0.146447 7.14645L3.293 4L0.146447 0.853553C-0.0271197 0.679987 -0.046405 0.410563 0.0885911 0.215694L0.146447 0.146447L0.0885911 0.215694Z" fill="#212121"/>
        </svg>
      </fluent-button>
    `;
    }
    /**
     * Displays the close button after selecting a channel.
     */
    showCloseIcon() {
        const downChevron = this.renderRoot.querySelector('.down-chevron');
        const upChevron = this.renderRoot.querySelector('.up-chevron');
        const closeIcon = this.renderRoot.querySelector('.close-icon');
        if (downChevron) {
            downChevron.style.display = 'none';
        }
        if (upChevron) {
            upChevron.style.display = 'none';
        }
        if (closeIcon) {
            closeIcon.style.display = null;
        }
    }
    /**
     * Renders down chevron icon
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderDownChevron() {
        return html `
      <fluent-button
        aria-label=${this.strings.downChevronButtonAriaLabel}
        appearance="stealth"
        class="down-chevron"
        @click=${this.gainedFocus}
        @keydown=${this.handleChevronKeydown}>
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M2.21967 4.46967C2.51256 4.17678 2.98744 4.17678 3.28033 4.46967L6 7.18934L8.71967 4.46967C9.01256 4.17678 9.48744 4.17678 9.78033 4.46967C10.0732 4.76256 10.0732 5.23744 9.78033 5.53033L6.53033 8.78033C6.23744 9.07322 5.76256 9.07322 5.46967 8.78033L2.21967 5.53033C1.92678 5.23744 1.92678 4.76256 2.21967 4.46967Z" fill="#212121" />
        </svg>
      </fluent-button>`;
    }
    /**
     * Renders up chevron icon
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderUpChevron() {
        return html `
      <fluent-button
        aria-label=${this.strings.upChevronButtonAriaLabel}
        appearance="stealth"
        style="display:none"
        class="up-chevron"
        @click=${this.handleUpChevronClick}
        @keydown=${this.handleChevronKeydown}>
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M2.21967 7.53033C2.51256 7.82322 2.98744 7.82322 3.28033 7.53033L6 4.81066L8.71967 7.53033C9.01256 7.82322 9.48744 7.82322 9.78033 7.53033C10.0732 7.23744 10.0732 6.76256 9.78033 6.46967L6.53033 3.21967C6.23744 2.92678 5.76256 2.92678 5.46967 3.21967L2.21967 6.46967C1.92678 6.76256 1.92678 7.23744 2.21967 7.53033Z" fill="#212121" />
        </svg>
      </fluent-button>`;
    }
    /**
     * Renders both chevrons
     */
    renderChevrons() {
        return html `${this.renderUpChevron()}${this.renderDownChevron()}`;
    }
    /**
     * Renders dropdown content
     *
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderDropdown() {
        if (this._task.status === TaskStatus.PENDING || !this._treeViewState) {
            return this.renderLoadingIndicator();
        }
        if (this._treeViewState) {
            if (this._treeViewState.length === 0 && this._inputValue.length > 0) {
                return this.renderError();
            }
            return this.renderDropdownList(this._treeViewState);
        }
        return html ``;
    }
    /**
     * Renders the dropdown list recursively
     *
     * @protected
     * @param {ChannelPickerItemState[]} items
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderDropdownList(items) {
        if (items && items.length > 0) {
            let icon = null;
            return html `
        <fluent-tree-view
          class="tree-view"
          dir=${this.direction}
          aria-live="polite"
          aria-relevant="all"
          aria-atomic="true"
          aria-label=${this.strings.teamsChannels}
          aria-orientation="horizontal"
          @keydown=${this.onKeydownTreeView}>
          ${repeat(items, (itemObj) => itemObj === null || itemObj === void 0 ? void 0 : itemObj.item, (obj) => {
                var _a;
                if (obj.channels) {
                    icon = html `<img
                  class="team-photo"
                  alt="${this.strings.photoFor} ${obj.item.displayName}"
                  src=${
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    (_a = this.teamsPhotos[obj.item.id]) === null || _a === void 0 ? void 0 : _a.photo} />`;
                }
                return html `
                <fluent-tree-item
                  ?expanded=${obj === null || obj === void 0 ? void 0 : obj.isExpanded}
                  @click=${this.handleTeamTreeItemClick}>
                    <span slot="start">${icon}</span>${obj.item.displayName}
                    ${repeat(obj === null || obj === void 0 ? void 0 : obj.channels, (channels) => channels.item, (channel) => {
                    return this.renderItem(channel);
                })}
                </fluent-tree-item>`;
            })}
        </fluent-tree-view>`;
        }
        return null;
    }
    /**
     * Renders each Channel or Team
     *
     * @param {ChannelPickerItemState} itemState
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderItem(itemState) {
        var _a;
        return html `
      <fluent-tree-item
        id=${(_a = itemState === null || itemState === void 0 ? void 0 : itemState.item) === null || _a === void 0 ? void 0 : _a.id}
        @keydown=${(e) => this.onUserKeyDown(e, itemState)}
        @click=${() => this.handleItemClick(itemState)}>
          ${itemState === null || itemState === void 0 ? void 0 : itemState.item.displayName}
      </fluent-tree-item>`;
    }
    /**
     * Queries Microsoft Graph for Teams & respective channels then sets to items list
     *
     * @protected
     * @memberof MgtTeamsChannelPicker
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            let teams;
            if (provider && provider.state === ProviderState.SignedIn) {
                const graph = provider.graph.forComponent(this);
                teams = yield getAllMyTeams(graph);
                teams = teams.filter(t => !t.isArchived);
                const teamsIds = teams.map(t => t.id);
                this.teamsPhotos = yield getTeamsPhotosForPhotoIds(graph, teamsIds);
                this._items = yield getChannelsForTeams(graph, teams);
            }
            this.filterList();
            this.resetFocusState();
        });
    }
    /**
     * Clears the selectedItem state.
     *
     * @memberof MgtTeamsChannelPicker
     */
    clearSelectedItem() {
        this.removeSelectedChannel();
    }
    /**
     * Handles operations that are performed on the DOM when you remove a
     * channel. For example on clicking the X button.
     *
     * @param item a selected channel item
     */
    removeSelectedChannel(item) {
        this.selectChannel(item);
        const treeItems = this.renderRoot.querySelectorAll('fluent-tree-item');
        if (treeItems) {
            treeItems.forEach((treeItem) => {
                treeItem.removeAttribute('expanded');
                treeItem.removeAttribute('selected');
            });
        }
    }
    handleItemClick(item) {
        if (item.channels) {
            item.isExpanded = !item.isExpanded;
        }
        else {
            this.selectChannel(item);
            this.lostFocus();
        }
    }
    onUserKeyDown(e, item) {
        const key = e.code;
        switch (key) {
            case 'Enter':
                this.selectChannel(item);
                this.resetFocusState();
                this.lostFocus();
                e.preventDefault();
                break;
            case 'Backspace':
                if (this._inputValue.length === 0 && this._selectedItemState) {
                    this.selectChannel(null);
                    this.resetFocusState();
                    e.preventDefault();
                }
                break;
        }
    }
    filterList() {
        if (this.items) {
            this._treeViewState = this.generateTreeViewState(this.items, this._inputValue);
            this.resetFocusState();
        }
    }
    generateTreeViewState(tree, filterString = '', parent = null) {
        const treeView = [];
        filterString = filterString.toLowerCase();
        if (tree) {
            for (const item of tree) {
                let stateItem;
                if (filterString.length === 0 || item.item.displayName.toLowerCase().includes(filterString)) {
                    stateItem = { item: item.item, parent };
                    if (item.channels) {
                        stateItem.channels = this.generateTreeViewState(item.channels, '', stateItem);
                        stateItem.isExpanded = filterString.length > 0;
                    }
                }
                else if (item.channels) {
                    const newStateItem = { item: item.item, parent };
                    const channels = this.generateTreeViewState(item.channels, filterString, newStateItem);
                    if (channels.length > 0) {
                        stateItem = newStateItem;
                        stateItem.channels = channels;
                        stateItem.isExpanded = true;
                    }
                }
                if (stateItem) {
                    treeView.push(stateItem);
                }
            }
        }
        return treeView;
    }
    // generates a flat list from a tree to facilitate easier focus
    // navigation
    generateFocusList(items) {
        if (!items || items.length === 0) {
            return [];
        }
        let array = [];
        for (const item of items) {
            array.push(item);
            if (item.channels && item.isExpanded) {
                array = [...array, ...this.generateFocusList(item.channels)];
            }
        }
        return array;
    }
    resetFocusState() {
        this._focusList = this.generateFocusList(this._treeViewState);
        this.requestUpdate();
    }
    selectChannel(item) {
        var _a, _b;
        if (item && this._selectedItemState !== item) {
            (_a = this._input) === null || _a === void 0 ? void 0 : _a.setAttribute('disabled', 'true');
        }
        else {
            (_b = this._input) === null || _b === void 0 ? void 0 : _b.removeAttribute('disabled');
        }
        this._selectedItemState = item;
        this.lostFocus();
        this.fireCustomEvent('selectionChanged', this.selectedItem);
    }
    /**
     * Hides the close icon.
     */
    hideCloseIcon() {
        const closeIcon = this.renderRoot.querySelector('.close-icon');
        if (closeIcon) {
            closeIcon.style.display = 'none';
        }
    }
    /**
     * Toggles the up and down chevron depending on the dropdown
     * visibility.
     */
    toggleChevron() {
        const downChevron = this.renderRoot.querySelector('.down-chevron');
        const upChevron = this.renderRoot.querySelector('.up-chevron');
        if (this._isDropdownVisible) {
            if (downChevron) {
                downChevron.style.display = 'none';
            }
            if (upChevron) {
                upChevron.style.display = null;
            }
        }
        else {
            if (downChevron) {
                downChevron.style.display = null;
                this.hideCloseIcon();
            }
            if (upChevron) {
                upChevron.style.display = 'none';
            }
        }
        this.hideCloseIcon();
    }
}
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtTeamsChannelPicker.prototype, "_selectedItemState", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtTeamsChannelPicker.prototype, "_isDropdownVisible", void 0);
//# sourceMappingURL=mgt-teams-channel-picker.js.map