/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { html } from 'lit';
import { property } from 'lit/decorators.js';
import { styles } from './mgt-file-css';
import { MgtTemplatedTaskComponent, Providers, ProviderState } from '@microsoft/mgt-element';
import { getDriveItemById, getDriveItemByPath, getDriveItemByQuery, getGroupDriveItemById, getGroupDriveItemByPath, getListDriveItemById, getMyDriveItemById, getMyDriveItemByPath, getMyInsightsDriveItemById, getSiteDriveItemById, getSiteDriveItemByPath, getUserDriveItemById, getUserDriveItemByPath, getUserInsightsDriveItemById } from '../../graph/graph.files';
import { formatBytes, getRelativeDisplayDate } from '../../utils/Utils';
import { viewTypeConverter } from '../../graph/types';
import { getFileTypeIconUriByExtension } from '../../styles/fluent-icons';
import { getSvg, SvgIcon } from '../../utils/SvgHelper';
import { strings } from './strings';
import { registerComponent } from '@microsoft/mgt-element';
export const registerMgtFileComponent = () => registerComponent('file', MgtFile);
/**
 * The File component is used to represent an individual file/folder from OneDrive or SharePoint by displaying information such as the file/folder name, an icon indicating the file type, and other properties such as the author, last modified date, or other details selected by the developer.
 *
 * @export
 * @class MgtFile
 * @extends {MgtTemplatedComponent}
 *
 * @cssprop --file-type-icon-height - {Length} file type icon height. Default value is 28px.
 * @cssprop --file-border - {String} file item border style. Default value is "1px solid transparent".
 * @cssprop --file-border-radius - {String} the border radius of the file component. Default value is 4px.
 * @cssprop --file-box-shadow - {String} the box-shadow of the component. Default value is none.
 * @cssprop --file-background-color - {Color} the background-color of the component.
 * @cssprop --file-background-color-focus - {Color} the background-color of the component on focus.
 * @cssprop --file-background-color-hover - {Color} the background-color of the component on hover.
 * @cssprop --file-padding - {String} the padding around the file component. Default value is 0px.
 * @cssprop --file-padding-inline-start - {Length} the padding between file icon and file details. Default value is 14px.
 * @cssprop --file-margin - {String} the margin around the file component. Default value is 0px.
 * @cssprop --file-line1-font-size - {Length} the first line text font size. Default value is 12px.
 * @cssprop --file-line1-font-weight - {Length} the first line text font weight. Default value is 400.
 * @cssprop --file-line1-color - {Color} the first line text color.
 * @cssprop --file-line1-text-transform - {String} the first line text text transform. Default value is initial.
 * @cssprop --file-line2-font-size - {Length} the second line text font size. Default value is 12px.
 * @cssprop --file-line2-font-weight - {Length} the second line text font weight. Default value is 400.
 * @cssprop --file-line2-color - {Color} the second line text color.
 * @cssprop --file-line2-text-transform - {String} the second line text text transform. Default value is initial.
 * @cssprop --file-line3-font-size - {Length} the third line text font size. Default value is 12px.
 * @cssprop --file-line3-font-weight - {Length} the third line text font weight. Default value is 400.
 * @cssprop --file-line3-color - {Color} the third line text color.
 * @cssprop --file-line3-text-transform - {String} the third line text text transform. Default value is 400.
 */
export class MgtFile extends MgtTemplatedTaskComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    get strings() {
        return strings;
    }
    /**
     * Get the scopes required for file
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtFile
     */
    static get requiredScopes() {
        return [...new Set(['files.read', 'files.read.all', 'sites.read.all'])];
    }
    args() {
        return [
            this.providerState,
            this.fileQuery,
            this.siteId,
            this.itemId,
            this.driveId,
            this.itemPath,
            this.listId,
            this.groupId,
            this.userId,
            this.insightType,
            this.insightId,
            this.fileDetails,
            this.fileIcon
        ];
    }
    constructor() {
        super();
        this.renderContent = () => {
            if (!this.driveItem) {
                return this.renderNoData();
            }
            const file = this.driveItem;
            let fileTemplate;
            fileTemplate = this.renderTemplate('default', { file });
            if (!fileTemplate) {
                const fileDetailsTemplate = this.renderDetails(file);
                const fileTypeIconTemplate = this.renderFileTypeIcon();
                fileTemplate = html `
        <div class="item">
          ${fileTypeIconTemplate} ${fileDetailsTemplate}
        </div>`;
            }
            return fileTemplate;
        };
        this.line1Property = 'name';
        this.line2Property = 'lastModifiedDateTime';
        this.line3Property = 'size';
        this.view = 'threelines';
    }
    /**
     * Render the state when no data is available
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtFile
     */
    renderNoData() {
        return this.renderTemplate('no-data', null) || html ``;
    }
    /**
     * Render the file type icon
     *
     * @protected
     * @param {string} [iconSrc]
     * @memberof MgtFile
     */
    renderFileTypeIcon() {
        if (!this.fileIcon && !this.driveItem.name) {
            return html ``;
        }
        let fileIconSrc;
        let fileType = '';
        if (this.fileIcon) {
            fileIconSrc = this.fileIcon;
        }
        else {
            // get file type extension from file name
            const re = /(?:\.([^.]+))?$/;
            fileType =
                this.driveItem.package === undefined && this.driveItem.folder === undefined
                    ? re.exec(this.driveItem.name)[1]
                        ? re.exec(this.driveItem.name)[1].toLowerCase()
                        : this.driveItem.size
                            ? 'null'
                            : 'folder'
                    : this.driveItem.package !== undefined
                        ? this.driveItem.package.type === 'oneNote'
                            ? 'onetoc'
                            : 'folder'
                        : 'folder';
            fileIconSrc = getFileTypeIconUriByExtension(fileType, 48, 'svg');
        }
        return html `
      <div class="item__file-type-icon">
        ${fileIconSrc
            ? html `
              <img src=${fileIconSrc} alt="${fileType.toUpperCase()} File icon" />
            `
            : html `
              ${getSvg(SvgIcon.File)}
            `}
      </div>
    `;
    }
    /**
     * Render the file details
     *
     * @protected
     * @param {MicrosoftGraph.DriveItem} [driveItem]
     * @memberof MgtFile
     */
    renderDetails(driveItem) {
        if (!driveItem || this.view === 'image') {
            return html ``;
        }
        const details = [];
        if (this.view > 'image') {
            const text = this.getTextFromProperty(driveItem, this.line1Property);
            if (text) {
                details.push(html `
          <div class="line1" aria-label="${text}">${text}</div>
        `);
            }
        }
        if (this.view > 'oneline') {
            const text = this.getTextFromProperty(driveItem, this.line2Property);
            if (text) {
                details.push(html `
          <div class="line2" aria-label="${text}">${text}</div>
        `);
            }
        }
        if (this.view > 'twolines') {
            const text = this.getTextFromProperty(driveItem, this.line3Property);
            if (text) {
                details.push(html `
          <div class="line3" aria-label="${text}">${text}</div>
        `);
            }
        }
        return html `
      <div class="item__details">
        ${details}
      </div>
    `;
    }
    /**
     * load state into the component.
     *
     * @protected
     * @returns
     * @memberof MgtFile
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.fileDetails) {
                this.driveItem = this.fileDetails;
                return;
            }
            const provider = Providers.globalProvider;
            if (!provider || provider.state === ProviderState.Loading) {
                return;
            }
            if (provider.state === ProviderState.SignedOut) {
                this.driveItem = null;
                return;
            }
            const graph = provider.graph.forComponent(this);
            let driveItem;
            // evaluate to true when only item-id or item-path is provided
            const getFromMyDrive = !this.driveId && !this.siteId && !this.groupId && !this.listId && !this.userId;
            if (
            // return null when a combination of provided properties are required
            (this.driveId && !this.itemId && !this.itemPath) ||
                (this.siteId && !this.itemId && !this.itemPath) ||
                (this.groupId && !this.itemId && !this.itemPath) ||
                (this.listId && !this.siteId && !this.itemId) ||
                (this.insightType && !this.insightId) ||
                (this.userId && !this.itemId && !this.itemPath && !this.insightType && !this.insightId)) {
                driveItem = null;
            }
            else if (this.fileQuery) {
                driveItem = yield getDriveItemByQuery(graph, this.fileQuery);
            }
            else if (this.itemId && getFromMyDrive) {
                driveItem = yield getMyDriveItemById(graph, this.itemId);
            }
            else if (this.itemPath && getFromMyDrive) {
                driveItem = yield getMyDriveItemByPath(graph, this.itemPath);
            }
            else if (this.userId) {
                if (this.itemId) {
                    driveItem = yield getUserDriveItemById(graph, this.userId, this.itemId);
                }
                else if (this.itemPath) {
                    driveItem = yield getUserDriveItemByPath(graph, this.userId, this.itemPath);
                }
                else if (this.insightType && this.insightId) {
                    driveItem = yield getUserInsightsDriveItemById(graph, this.userId, this.insightType, this.insightId);
                }
            }
            else if (this.driveId) {
                if (this.itemId) {
                    driveItem = yield getDriveItemById(graph, this.driveId, this.itemId);
                }
                else if (this.itemPath) {
                    driveItem = yield getDriveItemByPath(graph, this.driveId, this.itemPath);
                }
            }
            else if (this.siteId && !this.listId) {
                if (this.itemId) {
                    driveItem = yield getSiteDriveItemById(graph, this.siteId, this.itemId);
                }
                else if (this.itemPath) {
                    driveItem = yield getSiteDriveItemByPath(graph, this.siteId, this.itemPath);
                }
            }
            else if (this.listId) {
                driveItem = yield getListDriveItemById(graph, this.siteId, this.listId, this.itemId);
            }
            else if (this.groupId) {
                if (this.itemId) {
                    driveItem = yield getGroupDriveItemById(graph, this.groupId, this.itemId);
                }
                else if (this.itemPath) {
                    driveItem = yield getGroupDriveItemByPath(graph, this.groupId, this.itemPath);
                }
            }
            else if (this.insightType && !this.userId) {
                driveItem = yield getMyInsightsDriveItemById(graph, this.insightType, this.insightId);
            }
            this.driveItem = driveItem;
        });
    }
    getTextFromProperty(driveItem, properties) {
        if (!properties || properties.length === 0) {
            return null;
        }
        const propertyList = properties.trim().split(',');
        let text;
        let i = 0;
        while (!text && i < propertyList.length) {
            const current = propertyList[i].trim();
            switch (current) {
                case 'size': {
                    // convert size to kb, mb, gb
                    let size = '0';
                    if (driveItem.size) {
                        size = formatBytes(driveItem.size);
                    }
                    text = `${this.strings.sizeSubtitle}: ${size}`;
                    break;
                }
                case 'lastModifiedDateTime': {
                    // convert date time
                    let relativeDateString;
                    let lastModifiedString;
                    if (driveItem.lastModifiedDateTime) {
                        const lastModifiedDateTime = new Date(driveItem.lastModifiedDateTime);
                        relativeDateString = getRelativeDisplayDate(lastModifiedDateTime);
                        lastModifiedString = `${this.strings.modifiedSubtitle} ${relativeDateString}`;
                    }
                    else {
                        lastModifiedString = '';
                    }
                    text = lastModifiedString;
                    break;
                }
                default:
                    text = driveItem[current];
            }
            i++;
        }
        return text;
    }
}
__decorate([
    property({
        attribute: 'file-query'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "fileQuery", void 0);
__decorate([
    property({
        attribute: 'site-id'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "siteId", void 0);
__decorate([
    property({
        attribute: 'drive-id'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "driveId", void 0);
__decorate([
    property({
        attribute: 'group-id'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "groupId", void 0);
__decorate([
    property({
        attribute: 'list-id'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "listId", void 0);
__decorate([
    property({
        attribute: 'user-id'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "userId", void 0);
__decorate([
    property({
        attribute: 'item-id'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "itemId", void 0);
__decorate([
    property({
        attribute: 'item-path'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "itemPath", void 0);
__decorate([
    property({
        attribute: 'insight-type'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "insightType", void 0);
__decorate([
    property({
        attribute: 'insight-id'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "insightId", void 0);
__decorate([
    property({
        type: Object
    }),
    __metadata("design:type", Object)
], MgtFile.prototype, "fileDetails", void 0);
__decorate([
    property({
        attribute: 'file-icon'
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "fileIcon", void 0);
__decorate([
    property({ type: Object }),
    __metadata("design:type", Object)
], MgtFile.prototype, "driveItem", void 0);
__decorate([
    property({ attribute: 'line1-property' }),
    __metadata("design:type", String)
], MgtFile.prototype, "line1Property", void 0);
__decorate([
    property({ attribute: 'line2-property' }),
    __metadata("design:type", String)
], MgtFile.prototype, "line2Property", void 0);
__decorate([
    property({ attribute: 'line3-property' }),
    __metadata("design:type", String)
], MgtFile.prototype, "line3Property", void 0);
__decorate([
    property({
        attribute: 'view',
        converter: value => viewTypeConverter(value, 'threelines')
    }),
    __metadata("design:type", String)
], MgtFile.prototype, "view", void 0);
//# sourceMappingURL=mgt-file.js.map