/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CacheService, prepScopes } from '@microsoft/mgt-element';
import { getEmailFromGraphEntity } from '../../graph/graph.people';
import { MgtPersonCardConfig } from './MgtPersonCardConfig';
import { validUserByIdScopes } from '../../graph/graph.user';
import { validInsightScopes } from '../../graph/graph.files';
import { schemas } from '../../graph/cacheStores';
const userProperties = 'businessPhones,companyName,department,displayName,givenName,jobTitle,mail,mobilePhone,officeLocation,preferredLanguage,surname,userPrincipalName,id,accountEnabled';
const batchKeys = {
    directReports: 'directReports',
    files: 'files',
    messages: 'messages',
    people: 'people',
    person: 'person'
};
export const getCardStateInvalidationTime = () => CacheService.config.users.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
/**
 * Get data to populate the person card
 *
 * @export
 * @param {IGraph} graph
 * @param {IDynamicPerson} personDetails
 * @param {boolean} isMe
 * @param {MgtPersonCardConfig} config
 * @return {*}  {Promise<MgtPersonCardState>}
 */
export const getPersonCardGraphData = (graph, personDetails, isMe) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const userId = (personDetails === null || personDetails === void 0 ? void 0 : personDetails.id) || (personDetails === null || personDetails === void 0 ? void 0 : personDetails.userPrincipalName);
    const email = getEmailFromGraphEntity(personDetails);
    const cache = CacheService.getCache(schemas.users, schemas.users.stores.cardState);
    const cardState = yield cache.getValue(userId);
    if (cardState && getCardStateInvalidationTime() > Date.now() - cardState.timeCached) {
        return cardState;
    }
    const isContactOrGroup = 'classification' in personDetails ||
        ('personType' in personDetails &&
            (personDetails.personType.subclass === 'PersonalContact' || personDetails.personType.class === 'Group'));
    const batch = graph.createBatch();
    if (!isContactOrGroup) {
        if (MgtPersonCardConfig.sections.organization) {
            buildOrgStructureRequest(batch, userId);
            if (MgtPersonCardConfig.sections.organization.showWorksWith) {
                buildWorksWithRequest(batch, userId);
            }
        }
    }
    if (MgtPersonCardConfig.sections.mailMessages && email) {
        buildMessagesWithUserRequest(batch, email);
    }
    if (MgtPersonCardConfig.sections.files) {
        buildFilesRequest(batch, isMe ? null : email);
    }
    let response;
    const data = {}; // TODO
    try {
        response = yield batch.executeAll();
    }
    catch (_b) {
        // nop
    }
    if (response) {
        for (const [key, value] of response) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
            data[key] = ((_a = value.content) === null || _a === void 0 ? void 0 : _a.value) || value.content;
        }
    }
    if (!isContactOrGroup && MgtPersonCardConfig.sections.profile) {
        try {
            const profile = yield getProfile(graph, userId);
            if (profile) {
                data.profile = profile;
            }
        }
        catch (_c) {
            // nop
        }
    }
    // filter out disabled users from direct reports.
    if (data.directReports && data.directReports.length > 0) {
        data.directReports = data.directReports.filter(report => report.accountEnabled);
    }
    yield cache.putValue(userId, data);
    return data;
});
const buildOrgStructureRequest = (batch, userId) => {
    const expandManagers = `manager($levels=max;$select=${userProperties})`;
    batch.get(batchKeys.person, `users/${userId}?$expand=${expandManagers}&$select=${userProperties}&$count=true`, validUserByIdScopes, {
        ConsistencyLevel: 'eventual'
    });
    batch.get(batchKeys.directReports, `users/${userId}/directReports?$select=${userProperties}`);
};
const validPeopleScopes = ['People.Read.All'];
const buildWorksWithRequest = (batch, userId) => {
    batch.get(batchKeys.people, `users/${userId}/people?$filter=personType/class eq 'Person'`, validPeopleScopes);
};
const validMailSearchScopes = ['Mail.ReadBasic', 'Mail.Read', 'Mail.ReadWrite'];
const buildMessagesWithUserRequest = (batch, emailAddress) => {
    batch.get(batchKeys.messages, `me/messages?$search="from:${emailAddress}"`, validMailSearchScopes);
};
const buildFilesRequest = (batch, emailAddress) => {
    let request;
    if (emailAddress) {
        request = `me/insights/shared?$filter=lastshared/sharedby/address eq '${emailAddress}'`;
    }
    else {
        request = 'me/insights/used';
    }
    batch.get(batchKeys.files, request, validInsightScopes);
};
const validProfileScopes = ['User.Read.All', 'User.ReadWrite.All'];
/**
 * Get the profile for a user
 *
 * @param {IGraph} graph
 * @param {string} userId
 * @return {*}  {Promise<Profile>}
 */
const getProfile = (graph, userId) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield graph
        .api(`/users/${userId}/profile`)
        .version('beta')
        .middlewareOptions(prepScopes(validProfileScopes))
        .get());
});
const validCreateChatScopes = ['Chat.Create', 'Chat.ReadWrite'];
/**
 * Initiate a chat to a user
 *
 * @export
 * @param {IGraph} graph
 * @param {{ chatType: string; members: [{"@odata.type": string,"roles": ["owner"],"user@odata.bind": string},{"@odata.type": string,"roles": ["owner"],"user@odata.bind": string}]  }} chatData
 * @return {*}  {Promise<Chat>}
 */
export const createChat = (graph, person, user) => __awaiter(void 0, void 0, void 0, function* () {
    const chatData = {
        chatType: 'oneOnOne',
        members: [
            {
                '@odata.type': '#microsoft.graph.aadUserConversationMember',
                roles: ['owner'],
                'user@odata.bind': `https://graph.microsoft.com/v1.0/users('${user}')`
            },
            {
                '@odata.type': '#microsoft.graph.aadUserConversationMember',
                roles: ['owner'],
                'user@odata.bind': `https://graph.microsoft.com/v1.0/users('${person}')`
            }
        ]
    };
    return (yield graph
        .api('/chats')
        .header('Cache-Control', 'no-store')
        .middlewareOptions(prepScopes(validCreateChatScopes))
        .post(chatData));
});
const validSendChatMessageScopes = ['ChatMessage.Send', 'Chat.ReadWrite'];
/**
 * Send a chat message to a user
 *
 * @export
 * @param {IGraph} graph
 * @param {{ body: {"content": string}  }} messageData
 * @return {*}  {Promise<ChatMessage>}
 */
export const sendMessage = (graph, chatId, messageData) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield graph
        .api(`/chats/${chatId}/messages`)
        .header('Cache-Control', 'no-store')
        .middlewareOptions(prepScopes(validSendChatMessageScopes))
        .post(messageData));
});
//# sourceMappingURL=mgt-person-card.graph.js.map