{"version":3,"file":"graph.groups.js","sourceRoot":"src/","sources":["graph/graph.groups.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\nimport {\n  IGraph,\n  prepScopes,\n  CacheItem,\n  CacheService,\n  CacheStore,\n  BatchResponse,\n  CollectionResponse\n} from '@microsoft/mgt-element';\nimport { Group } from '@microsoft/microsoft-graph-types';\nimport { schemas } from './cacheStores';\n\nconst groupTypeValues = ['any', 'unified', 'security', 'mailenabledsecurity', 'distribution'] as const;\n\n/**\n * Group Type enumeration\n *\n * @export\n * @enum {string}\n */\nexport type GroupType = (typeof groupTypeValues)[number];\nexport const isGroupType = (value: unknown): value is GroupType =>\n  typeof value === 'string' && groupTypeValues.includes(value as GroupType);\nexport const groupTypeConverter = (value: string, defaultValue: GroupType = 'any'): GroupType =>\n  isGroupType(value) ? value : defaultValue;\n\n/**\n * Object to be stored in cache\n */\nexport interface CacheGroup extends CacheItem {\n  /**\n   * stringified json representing a user\n   */\n  group?: string;\n}\n\n/**\n * Object to be stored in cache representing individual people\n */\ninterface CacheGroupQuery extends CacheItem {\n  /**\n   * json representing a person stored as string\n   */\n  groups?: string[];\n  /**\n   * top number of results\n   */\n  top?: number;\n}\n\n/**\n * Defines the expiration time\n */\nconst getGroupsInvalidationTime = (): number =>\n  CacheService.config.groups.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;\n\n/**\n * Whether the groups store is enabled\n */\nconst getIsGroupsCacheEnabled = (): boolean => CacheService.config.groups.isEnabled && CacheService.config.isEnabled;\n\nconst validGroupQueryScopes = [\n  'GroupMember.Read.All',\n  'Group.Read.All',\n  'Directory.Read.All',\n  'Group.ReadWrite.All',\n  'Directory.ReadWrite.All'\n];\n\nconst validTransitiveGroupMemberScopes = [\n  'GroupMember.Read.All',\n  'Group.Read.All',\n  'Directory.Read.All',\n  'GroupMember.ReadWrite.All',\n  'Group.ReadWrite.All'\n];\n\n/**\n * Searches the Graph for Groups\n *\n * @export\n * @param {IGraph} graph\n * @param {string} query - what to search for\n * @param {number} [top=10] - number of groups to return\n * @param {GroupType} [groupTypes=[\"any\"]] - the type of group to search for\n * @returns {Promise<Group[]>} An array of Groups\n */\nexport const findGroups = async (\n  graph: IGraph,\n  query: string,\n  top = 10,\n  groupTypes: GroupType[] = ['any'],\n  groupFilters = ''\n): Promise<Group[]> => {\n  let cache: CacheStore<CacheGroupQuery>;\n  const key = `${query ? query : '*'}*${groupTypes.join('+')}*${groupFilters}:${top}`;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groupsQuery);\n    const cacheGroupQuery = await cache.getValue(key);\n    if (cacheGroupQuery && getGroupsInvalidationTime() > Date.now() - cacheGroupQuery.timeCached) {\n      if (cacheGroupQuery.top >= top) {\n        // if request is less than the cache's requests, return a slice of the results\n        return cacheGroupQuery.groups.map(x => JSON.parse(x) as Group).slice(0, top + 1);\n      }\n      // if the new request needs more results than what's presently in the cache, graph must be called again\n    }\n  }\n\n  let filterQuery = '';\n  let responses: Map<string, BatchResponse<CollectionResponse<Group>>>;\n  const batchedResult: Group[] = [];\n\n  if (query !== '') {\n    filterQuery = `(startswith(displayName,'${query}') or startswith(mailNickname,'${query}') or startswith(mail,'${query}'))`;\n  }\n\n  if (groupFilters) {\n    filterQuery += `${query ? ' and ' : ''}${groupFilters}`;\n  }\n\n  if (!groupTypes.includes('any')) {\n    const batch = graph.createBatch<CollectionResponse<Group>>();\n\n    const filterGroups: string[] = [];\n\n    if (groupTypes.includes('unified')) {\n      filterGroups.push(\"groupTypes/any(c:c+eq+'Unified')\");\n    }\n\n    if (groupTypes.includes('security')) {\n      filterGroups.push('(mailEnabled eq false and securityEnabled eq true)');\n    }\n\n    if (groupTypes.includes('mailenabledsecurity')) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq true)');\n    }\n\n    if (groupTypes.includes('distribution')) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq false)');\n    }\n\n    filterQuery = filterQuery ? `${filterQuery} and ` : '';\n    for (const filter of filterGroups) {\n      const fullUrl = `/groups?$filter=${filterQuery + filter}&$top=${top}`;\n      batch.get(filter, fullUrl, validGroupQueryScopes);\n    }\n\n    try {\n      responses = await batch.executeAll();\n\n      for (const filterGroup of filterGroups) {\n        if (responses.get(filterGroup).content.value) {\n          for (const group of responses.get(filterGroup).content.value) {\n            const repeat = batchedResult.find(batchedGroup => batchedGroup.id === group.id);\n            if (!repeat) {\n              batchedResult.push(group);\n            }\n          }\n        }\n      }\n    } catch (_) {\n      try {\n        const queries: Promise<CollectionResponse<Group>>[] = [];\n        for (const filter of filterGroups) {\n          queries.push(\n            graph\n              .api('groups')\n              .filter(`${filterQuery} and ${filter}`)\n              .top(top)\n              .count(true)\n              .header('ConsistencyLevel', 'eventual')\n              .middlewareOptions(prepScopes(validGroupQueryScopes))\n              .get() as Promise<CollectionResponse<Group>>\n          );\n        }\n        return (await Promise.all(queries)).map(x => x.value).reduce((a, b) => a.concat(b), []);\n      } catch (e) {\n        return [];\n      }\n    }\n  } else {\n    if (batchedResult.length === 0) {\n      const result = (await graph\n        .api('groups')\n        .filter(filterQuery)\n        .top(top)\n        .count(true)\n        .header('ConsistencyLevel', 'eventual')\n        .middlewareOptions(prepScopes(validGroupQueryScopes))\n        .get()) as CollectionResponse<Group>;\n      if (getIsGroupsCacheEnabled() && result) {\n        await cache.putValue(key, { groups: result.value.map(x => JSON.stringify(x)), top });\n      }\n      return result ? result.value : null;\n    }\n  }\n\n  return batchedResult;\n};\n\n/**\n * Searches the Graph for group members\n *\n * @export\n * @param {IGraph} graph\n * @param {string} query - what to search for\n * @param {string} groupId - what to search for\n * @param {number} [top=10] - number of groups to return\n * @param {boolean} [transitive=false] - whether the return should contain a flat list of all nested members\n * @param {GroupType} [groupTypes=[\"any\"]] - the type of group to search for\n * @returns {Promise<Group[]>} An array of Groups\n */\nexport const findGroupsFromGroup = async (\n  graph: IGraph,\n  query: string,\n  groupId: string,\n  top = 10,\n  transitive = false,\n  groupTypes: GroupType[] = ['any']\n): Promise<Group[]> => {\n  let cache: CacheStore<CacheGroupQuery>;\n  const key = `${groupId}:${query || '*'}:${groupTypes.join('+')}:${transitive}`;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groupsQuery);\n    const cacheGroupQuery = await cache.getValue(key);\n    if (cacheGroupQuery && getGroupsInvalidationTime() > Date.now() - cacheGroupQuery.timeCached) {\n      if (cacheGroupQuery.top >= top) {\n        // if request is less than the cache's requests, return a slice of the results\n        return cacheGroupQuery.groups.map(x => JSON.parse(x) as Group).slice(0, top + 1);\n      }\n      // if the new request needs more results than what's presently in the cache, graph must be called again\n    }\n  }\n\n  const apiUrl = `groups/${groupId}/${transitive ? 'transitiveMembers' : 'members'}/microsoft.graph.group`;\n  let filterQuery = '';\n  if (query !== '') {\n    filterQuery = `(startswith(displayName,'${query}') or startswith(mailNickname,'${query}') or startswith(mail,'${query}'))`;\n  }\n\n  if (!groupTypes.includes('any')) {\n    const filterGroups = [];\n\n    if (groupTypes.includes('unified')) {\n      filterGroups.push(\"groupTypes/any(c:c+eq+'Unified')\");\n    }\n\n    if (groupTypes.includes('security')) {\n      filterGroups.push('(mailEnabled eq false and securityEnabled eq true)');\n    }\n\n    if (groupTypes.includes('mailenabledsecurity')) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq true)');\n    }\n\n    if (groupTypes.includes('distribution')) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq false)');\n    }\n\n    filterQuery += (query !== '' ? ' and ' : '') + filterGroups.join(' or ');\n  }\n\n  const result = (await graph\n    .api(apiUrl)\n    .filter(filterQuery)\n    .count(true)\n    .top(top)\n    .header('ConsistencyLevel', 'eventual')\n    .middlewareOptions(prepScopes(validTransitiveGroupMemberScopes))\n    .get()) as CollectionResponse<Group>;\n\n  if (getIsGroupsCacheEnabled() && result) {\n    await cache.putValue(key, { groups: result.value.map(x => JSON.stringify(x)), top });\n  }\n\n  return result ? result.value : null;\n};\n\n/**\n * async promise, returns all Graph groups associated with the id provided\n *\n * @param {string} id\n * @returns {(Promise<User>)}\n * @memberof Graph\n */\nexport const getGroup = async (graph: IGraph, id: string, requestedProps?: string[]): Promise<Group> => {\n  let cache: CacheStore<CacheGroup>;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);\n    // check cache\n    const group = await cache.getValue(id);\n\n    // is it stored and is timestamp good?\n    if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {\n      const cachedData = group.group ? (JSON.parse(group.group) as Group) : null;\n      const uniqueProps =\n        requestedProps && cachedData ? requestedProps.filter(prop => !Object.keys(cachedData).includes(prop)) : null;\n\n      // return without any worries\n      if (!uniqueProps || uniqueProps.length <= 1) {\n        return cachedData;\n      }\n    }\n  }\n\n  let apiString = `/groups/${id}`;\n  if (requestedProps) {\n    apiString = apiString + '?$select=' + requestedProps.toString();\n  }\n\n  // else we must grab it\n  const response = (await graph.api(apiString).middlewareOptions(prepScopes(validGroupQueryScopes)).get()) as Group;\n  if (getIsGroupsCacheEnabled()) {\n    await cache.putValue(id, { group: JSON.stringify(response) });\n  }\n  return response;\n};\n\n/**\n * Returns a Promise of Graph Groups array associated with the groupIds array\n *\n * @export\n * @param {IGraph} graph\n * @param {string[]} groupIds, an array of string ids\n * @returns {Promise<Group[]>}\n */\nexport const getGroupsForGroupIds = async (graph: IGraph, groupIds: string[], filters = ''): Promise<Group[]> => {\n  if (!groupIds || groupIds.length === 0) {\n    return [];\n  }\n  const batch = graph.createBatch();\n  const groupDict: Record<string, Group | Promise<Group>> = {};\n  const notInCache: string[] = [];\n  let cache: CacheStore<CacheGroup>;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);\n  }\n\n  for (const id of groupIds) {\n    groupDict[id] = null;\n    let group: CacheGroup;\n    if (getIsGroupsCacheEnabled()) {\n      group = await cache.getValue(id);\n    }\n    if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {\n      groupDict[id] = group.group ? (JSON.parse(group.group) as Group) : null;\n    } else if (id !== '') {\n      let apiUrl = `/groups/${id}`;\n      if (filters) {\n        apiUrl = `${apiUrl}?$filters=${filters}`;\n      }\n      batch.get(id, apiUrl, validGroupQueryScopes);\n      notInCache.push(id);\n    }\n  }\n  try {\n    const responses = await batch.executeAll();\n    // iterate over groupIds to ensure the order of ids\n    for (const id of groupIds) {\n      const response = responses.get(id);\n      if (response?.content) {\n        groupDict[id] = response.content as Group;\n        if (getIsGroupsCacheEnabled()) {\n          await cache.putValue(id, { group: JSON.stringify(response.content) });\n        }\n      }\n    }\n    return Promise.all(Object.values(groupDict));\n  } catch (_) {\n    // fallback to making the request one by one\n    try {\n      // call getGroup for all the users that weren't cached\n      groupIds\n        .filter(id => notInCache.includes(id))\n        .forEach(id => {\n          groupDict[id] = getGroup(graph, id);\n        });\n      if (getIsGroupsCacheEnabled()) {\n        // store all users that weren't retrieved from the cache, into the cache\n        await Promise.all(\n          groupIds\n            .filter(id => notInCache.includes(id))\n            .map(async id => await cache.putValue(id, { group: JSON.stringify(await groupDict[id]) }))\n        );\n      }\n      return Promise.all(Object.values(groupDict));\n    } catch (e) {\n      return [];\n    }\n  }\n};\n\n/**\n * Gets groups from the graph that are in the group ids\n *\n * @param graph\n * @param query\n * @param groupId\n * @param top\n * @param transitive\n * @param groupTypes\n * @param filters\n * @returns\n */\nexport const findGroupsFromGroupIds = async (\n  graph: IGraph,\n  query: string,\n  groupIds: string[],\n  top = 10,\n  groupTypes: GroupType[] = ['any'],\n  filters = ''\n): Promise<Group[]> => {\n  const foundGroups: Group[] = [];\n  const graphGroups = await findGroups(graph, query, top, groupTypes, filters);\n  if (graphGroups) {\n    for (const group of graphGroups) {\n      if (group.id && groupIds.includes(group.id)) {\n        foundGroups.push(group);\n      }\n    }\n  }\n  return foundGroups;\n};\n"]}