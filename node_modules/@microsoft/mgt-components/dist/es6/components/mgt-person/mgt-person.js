/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { fluentSkeleton } from '@fluentui/web-components';
import { MgtTemplatedTaskComponent, ProviderState, Providers, buildComponentName, customElementHelper, mgtHtml, registerComponent } from '@microsoft/mgt-element';
import { html, nothing } from 'lit';
import { property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { isContact, isUser } from '../../graph/entityType';
import { findPeople, getEmailFromGraphEntity } from '../../graph/graph.people';
import { getGroupImage, getPersonImage } from '../../graph/graph.photos';
import { getUserPresence } from '../../graph/graph.presence';
import { findUsers, getMe, getUser } from '../../graph/graph.user';
import { getUserWithPhoto } from '../../graph/graph.userWithPhoto';
import { viewTypeConverter } from '../../graph/types';
import '../../styles/style-helper';
import { registerFluentComponents } from '../../utils/FluentComponents';
import { SvgIcon, getSvg } from '../../utils/SvgHelper';
import { debounce } from '../../utils/Utils';
import '../sub-components/mgt-flyout/mgt-flyout';
import { registerMgtFlyoutComponent } from '../sub-components/mgt-flyout/mgt-flyout';
import { personCardConverter } from './../PersonCardInteraction';
import { styles } from './mgt-person-css';
import { avatarTypeConverter } from './mgt-person-types';
import { strings } from './strings';
import { getPersonCardGraphData } from '../mgt-person-card/mgt-person-card.graph';
/**
 * Person properties part of original set provided by graph by default
 */
export const defaultPersonProperties = [
    'businessPhones',
    'displayName',
    'givenName',
    'jobTitle',
    'department',
    'mail',
    'mobilePhone',
    'officeLocation',
    'preferredLanguage',
    'surname',
    'userPrincipalName',
    'id',
    'userType'
];
export const registerMgtPersonComponent = () => {
    registerFluentComponents(fluentSkeleton);
    // register self first to avoid infinte loop due to circular ref between person and person card
    registerComponent('person', MgtPerson);
    registerMgtFlyoutComponent();
};
/**
 * The person component is used to display a person or contact by using their photo, name, and/or email address.
 *
 * @export
 * @class MgtPerson
 * @extends {MgtTemplatedComponent}
 *
 * @fires {CustomEvent<IDynamicPerson>} line1clicked - Fired when line1 is clicked
 * @fires {CustomEvent<IDynamicPerson>} line2clicked - Fired when line2 is clicked
 * @fires {CustomEvent<IDynamicPerson>} line3clicked - Fired when line3 is clicked
 * @fires {CustomEvent<IDynamicPerson>} line4clicked - Fired when line4 is clicked
 *
 * @cssprop --person-background-color - {Color} the color of the person component background.
 * @cssprop --person-background-border-radius - {Length} the border radius of the person component. Default is 4px.
 *
 * @cssprop --person-avatar-size - {Length} the width and height of the avatar. Default is 24px.
 * @cssprop --person-avatar-border - {String} the border around an avatar. Default is none.
 * @cssprop --person-avatar-border-radius - {String} the radius around the border of an avatar. Default is 50%.
 *
 * @cssprop --person-initials-text-color - {Color} the color of initials in an avatar.
 * @cssprop --person-initials-background-color - {Color} the color of the background in an avatar with initials.
 *
 * @cssprop --person-details-spacing - {Length} the space between the avatar and the person details. Default is 12px.
 *
 * @cssprop --person-line1-font-size - {String} the font-size of the line 1 text. Default is 14px.
 * @cssprop --person-line1-font-weight - {Length} the font weight of the line 1 text. Default is 600.
 * @cssprop --person-line1-text-color - {Color} the color of the line 1 text.
 * @cssprop --person-line1-text-transform - {String} the tex transform of the line 1 text. Default is inherit.
 * @cssprop --person-line1-text-line-height - {Length} the line height of the line 1 text. Default is 20px.
 *
 * @cssprop --person-line2-font-size - {Length} the font-size of the line 2 text. Default is 12px.
 * @cssprop --person-line2-font-weight - {Length} the font weight of the line 2 text. Default is 400.
 * @cssprop --person-line2-text-color - {Color} the color of the line 2 text.
 * @cssprop --person-line2-text-transform - {String} the tex transform of the line 2 text. Default is inherit.
 * @cssprop --person-line2-text-line-height - {Length} the line height of the line 2 text. Default is 16px.
 *
 * @cssprop --person-line3-font-size - {Length} the font-size of the line 3 text. Default is 12px.
 * @cssprop --person-line3-font-weight - {Length} the font weight of the line 3 text. Default is 400.
 * @cssprop --person-line3-text-color - {Color} the color of the line 3 text.
 * @cssprop --person-line3-text-transform - {String} the tex transform of the line 3 text. Default is inherit.
 * @cssprop --person-line3-text-line-height - {Length} the line height of the line 3 text. Default is 16px.
 *
 * @cssprop --person-line4-font-size - {Length} the font-size of the line 4 text. Default is 12px.
 * @cssprop --person-line4-font-weight - {Length} the font weight of the line 4 text. Default is 400.
 * @cssprop --person-line4-text-color - {Color} the color of the line 4 text.
 * @cssprop --person-line4-text-transform - {String} the tex transform of the line 4 text. Default is inherit.
 * @cssprop --person-line4-text-line-height - {Length} the line height of the line 4 text. Default is 16px.
 *
 * @cssprop --person-details-wrapper-width - {Length} the minimum width of the details section. Default is 168px.
 */
export class MgtPerson extends MgtTemplatedTaskComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    /**
     * Strings to use for localization
     *
     * @readonly
     * @protected
     * @memberof MgtPerson
     */
    get strings() {
        return strings;
    }
    /**
     * allows developer to define name of person for component
     *
     * @type {string}
     */
    get personQuery() {
        return this._personQuery;
    }
    set personQuery(value) {
        if (value === this._personQuery) {
            return;
        }
        this._personQuery = value;
        this._personDetails = null;
        this.personDetailsInternal = null;
    }
    /**
     * Fallback when no user is found
     *
     * @type {IDynamicPerson}
     */
    get fallbackDetails() {
        return this._fallbackDetails;
    }
    set fallbackDetails(value) {
        if (value === this._fallbackDetails) {
            return;
        }
        this._fallbackDetails = value;
        if (this.personDetailsInternal) {
            return;
        }
    }
    /**
     * user-id property allows developer to use id value to determine person
     *
     * @type {string}
     */
    get userId() {
        return this._userId;
    }
    set userId(value) {
        if (value === this._userId) {
            return;
        }
        this._userId = value;
        this.personDetailsInternal = null;
        this._personDetails = null;
    }
    /**
     * usage property allows you to specify where the component is being used to add
     * customized personalization for it. Currently only supports "people" and "people-picker" as used in
     * the people component.
     *
     * @type {string}
     */
    get usage() {
        return this._usage;
    }
    set usage(value) {
        if (value === this._usage) {
            return;
        }
        this._usage = value;
    }
    /**
     * object containing Graph details on person
     * a copy of person-details attribute
     *
     * @type {IDynamicPerson}
     */
    get personDetailsInternal() {
        return this._personDetailsInternal;
    }
    set personDetailsInternal(value) {
        if (this._personDetailsInternal === value) {
            return;
        }
        this._personDetailsInternal = value;
        this._fetchedImage = null;
        this._fetchedPresence = null;
    }
    /**
     * object containing Graph details on person
     *
     * @type {IDynamicPerson}
     */
    get personDetails() {
        return this._personDetails;
    }
    set personDetails(value) {
        if (this._personDetails === value) {
            return;
        }
        this._personDetails = value;
        this._fetchedImage = null;
        this._fetchedPresence = null;
    }
    /**
     * Set the image of the person
     *
     * @type {string}
     * @memberof MgtPersonCard
     */
    get personImage() {
        return this._personImage || this._fetchedImage;
    }
    set personImage(value) {
        if (value === this._personImage) {
            return;
        }
        this._isInvalidImageSrc = !value;
        this._personImage = value;
    }
    /**
     * Gets or sets presence of person
     *
     * @type {MicrosoftGraph.Presence}
     * @memberof MgtPerson
     */
    get personPresence() {
        return this._personPresence || this._fetchedPresence;
    }
    set personPresence(value) {
        if (value === this._personPresence) {
            return;
        }
        this._personPresence = value;
    }
    /**
     * Get the scopes required for person
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtPerson
     */
    static get requiredScopes() {
        const scopes = ['user.readbasic.all', 'user.read', 'people.read', 'presence.read.all', 'presence.read'];
        if (MgtPerson.config.useContactApis) {
            scopes.push('contacts.read');
        }
        return scopes;
    }
    /**
     * Gets the flyout element
     *
     * @protected
     * @type {MgtFlyout}
     * @memberof MgtPerson
     */
    get flyout() {
        return this.renderRoot.querySelector('.flyout');
    }
    constructor() {
        super();
        /**
         * Determines and sets person avatar view
         * Valid options are 'photo' or 'initials'
         *
         * @type {AvatarType}
         * @memberof MgtPerson
         */
        this.avatarType = 'photo';
        /**
         * Sets how the person-card is invoked
         * Valid options are: 'none', 'hover', or 'click'
         * Set to 'none' to not show the card
         *
         * @type {PersonCardInteraction}
         * @memberof MgtPerson
         */
        this.personCardInteraction = 'none';
        /**
         * Sets what data to be rendered.
         * Valid options are 'image', 'oneline', 'twolines', 'threelines', or 'fourlines'
         * Default is 'image'.
         *
         * @type {ViewType}
         * @memberof MgtPerson
         */
        this.view = 'image';
        this._hasLoadedPersonCard = false;
        this._mouseLeaveTimeout = -1;
        this._mouseEnterTimeout = -1;
        this.renderContent = () => {
            // Prep data
            const person = this.personDetails || this.personDetailsInternal || this.fallbackDetails;
            const image = this.getImage();
            const presence = this.personPresence || this._fetchedPresence;
            if (!person && !image) {
                return this.renderNoData();
            }
            if (!(person === null || person === void 0 ? void 0 : person.personImage) && image) {
                person.personImage = image;
            }
            // Default template
            let personTemplate = this.renderTemplate('default', { person, personImage: image, personPresence: presence });
            if (!personTemplate) {
                const detailsTemplate = this.renderDetails(person, presence);
                const imageWithPresenceTemplate = this.renderAvatar(person, image, presence);
                personTemplate = html `
        ${imageWithPresenceTemplate}
        ${detailsTemplate}
      `;
            }
            const showPersonCard = this.personCardInteraction !== 'none';
            if (showPersonCard) {
                personTemplate = this.renderFlyout(personTemplate, person, image, presence);
            }
            const rootClasses = classMap({
                'person-root': true,
                small: !this.isThreeLines() && !this.isFourLines() && !this.isLargeAvatar(),
                large: this.avatarSize !== 'auto' && this.isLargeAvatar(),
                noline: this.isNoLine(),
                oneline: this.isOneLine(),
                twolines: this.isTwoLines(),
                threelines: this.isThreeLines(),
                fourlines: this.isFourLines(),
                vertical: this.isVertical()
            });
            return html `
      <div
        class="${rootClasses}"
        dir=${this.direction}
        @click=${this.handleMouseClick}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
        @keydown=${this.handleKeyDown}
        tabindex="${ifDefined(this.personCardInteraction !== 'none' ? '0' : undefined)}"
      >
        ${personTemplate}
      </div>
    `;
        };
        /**
         * Render the loading state
         *
         * @protected
         * @returns {TemplateResult}
         * @memberof MgtPerson
         */
        this.renderLoading = () => {
            const rootClasses = classMap({
                'person-root': true,
                small: !this.isThreeLines() && !this.isFourLines() && !this.isLargeAvatar(),
                large: this.avatarSize !== 'auto' && this.isLargeAvatar(),
                noline: this.isNoLine(),
                oneline: this.isOneLine(),
                twolines: this.isTwoLines(),
                threelines: this.isThreeLines(),
                fourlines: this.isFourLines(),
                vertical: this.isVertical()
            });
            const detailsClasses = classMap({
                'details-wrapper': true,
                vertical: this.isVertical()
            });
            return (this.renderTemplate('loading', null) ||
                html `
        <div class="${rootClasses}">
          <div class="avatar-wrapper">
            <fluent-skeleton shimmer class="shimmer" shape="circle"></fluent-skeleton>
          </div>
          <div class=${detailsClasses}>
            ${this.renderLoadingLines()}
          </div>
        </div>`);
        };
        this.renderLoadingLines = () => {
            const lines = [];
            if (this.isNoLine())
                return lines;
            if (this.isOneLine()) {
                lines.push(this.renderLoadingLine(1));
            }
            if (this.isTwoLines()) {
                lines.push(this.renderLoadingLine(1));
                lines.push(this.renderLoadingLine(2));
            }
            if (this.isThreeLines()) {
                lines.push(this.renderLoadingLine(1));
                lines.push(this.renderLoadingLine(2));
                lines.push(this.renderLoadingLine(3));
            }
            if (this.isFourLines()) {
                lines.push(this.renderLoadingLine(1));
                lines.push(this.renderLoadingLine(2));
                lines.push(this.renderLoadingLine(3));
                lines.push(this.renderLoadingLine(4));
            }
            return lines;
        };
        this.renderLoadingLine = (line) => {
            const lineNumber = `line${line}`;
            return html `
      <div class=${lineNumber}>
        <fluent-skeleton shimmer class="shimmer text" shape="rect"></fluent-skeleton>
      </div>
    `;
        };
        this.handleMouseClick = (e) => {
            const element = e.target;
            // todo: fix for disambiguation
            if (this.personCardInteraction === 'click' &&
                element.tagName !== `${customElementHelper.prefix}-PERSON-CARD`.toUpperCase()) {
                this.showPersonCard();
            }
        };
        this.handleKeyDown = (e) => {
            const personEl = this.renderRoot.querySelector('.person-root');
            // enter activates and focuses on person-card
            if (e) {
                if (e.key === 'Enter') {
                    this.showPersonCard();
                    const flyout = this.flyout;
                    if (flyout === null || flyout === void 0 ? void 0 : flyout.isOpen) {
                        this._keyBoardFocus = debounce(() => {
                            const personCardEl = flyout.querySelector('.mgt-person-card');
                            personCardEl.setAttribute('tabindex', '0');
                            personCardEl.focus();
                        }, 500);
                        this._keyBoardFocus();
                    }
                    personEl.blur();
                }
                if (this.personCardInteraction !== 'none') {
                    if (e.key === 'Escape' && personEl) {
                        this.hidePersonCard();
                        personEl.focus();
                    }
                }
            }
        };
        this.handleMouseEnter = () => {
            clearTimeout(this._mouseEnterTimeout);
            clearTimeout(this._mouseLeaveTimeout);
            if (this.personCardInteraction !== 'hover') {
                return;
            }
            this._mouseEnterTimeout = window.setTimeout(this.showPersonCard, 500);
        };
        this.handleMouseLeave = () => {
            clearTimeout(this._mouseEnterTimeout);
            clearTimeout(this._mouseLeaveTimeout);
            this._mouseLeaveTimeout = window.setTimeout(this.hidePersonCard, 500);
        };
        /**
         * hides the person card
         *
         * @memberof MgtPerson
         */
        this.hidePersonCard = () => {
            const flyout = this.flyout;
            if (flyout) {
                flyout.close();
            }
            const personCard = this.querySelector('.mgt-person-card') ||
                this.renderRoot.querySelector('.mgt-person-card');
            if (personCard) {
                personCard.isExpanded = false;
                personCard.clearHistory();
            }
        };
        this.loadPersonCardResources = () => __awaiter(this, void 0, void 0, function* () {
            // if there could be a person-card then we should load those resources using a dynamic import
            if (this.personCardInteraction !== 'none' && !this._hasLoadedPersonCard) {
                const { registerMgtPersonCardComponent } = yield import('../mgt-person-card/mgt-person-card');
                // only register person card if it hasn't been registered yet
                if (!customElements.get(buildComponentName('person-card')))
                    registerMgtPersonCardComponent();
                this._hasLoadedPersonCard = true;
            }
        });
        this.showPersonCard = () => {
            if (!this._personCardShouldRender) {
                this._personCardShouldRender = true;
                void this.loadPersonCardResources();
            }
            const flyout = this.flyout;
            if (flyout) {
                flyout.open();
            }
        };
        // defaults
        this.personCardInteraction = 'none';
        this.line1Property = 'displayName';
        this.line2Property = 'jobTitle';
        this.line3Property = 'department';
        this.line4Property = 'email';
        this.view = 'image';
        this.avatarSize = 'auto';
        this.disableImageFetch = false;
        this._isInvalidImageSrc = false;
        this.avatarType = 'photo';
        this.verticalLayout = false;
    }
    /**
     * Clears state of the component
     *
     * @protected
     * @memberof MgtPerson
     */
    clearState() {
        this._personImage = '';
        this._personDetailsInternal = null;
        this._fetchedImage = null;
        this._fetchedPresence = null;
    }
    /**
     * Render the state when no data is available
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPerson
     */
    renderNoData() {
        const noDataTemplate = this.renderTemplate('no-data', null);
        if (noDataTemplate) {
            return noDataTemplate;
        }
        const avatarClasses = {
            'avatar-icon': true,
            vertical: this.isVertical(),
            small: !this.isLargeAvatar(),
            noline: this.isNoLine(),
            oneline: this.isOneLine(),
            twolines: this.isTwoLines(),
            threelines: this.isThreeLines(),
            fourlines: this.isFourLines()
        };
        return html `
       <i class=${classMap(avatarClasses)}></i>
     `;
    }
    /**
     * Render a person icon.
     *
     * @protected
     * @returns
     * @memberof MgtPerson
     */
    renderPersonIcon() {
        return getSvg(SvgIcon.Person);
    }
    /**
     * Render the image part of the person template.
     * If the image is unavailable, the person's initials will be used instead.
     *
     * @protected
     * @param {string} [imageSrc]
     * @param {IDynamicPerson} [personDetailsInternal]
     * @returns
     * @memberof MgtPerson
     */
    renderImage(personDetailsInternal, imageSrc) {
        var _a;
        const altText = `${this.strings.photoFor} ${personDetailsInternal.displayName}`;
        const hasImage = imageSrc && !this._isInvalidImageSrc && this.avatarType === 'photo';
        const imageOnly = this.avatarType === 'photo' && this.view === 'image';
        const titleText = (_a = ((personDetailsInternal === null || personDetailsInternal === void 0 ? void 0 : personDetailsInternal.displayName) ||
            `${this.strings.emailAddress} ${getEmailFromGraphEntity(personDetailsInternal)}`)) !== null && _a !== void 0 ? _a : undefined;
        const imageTemplate = html `<img
      title="${ifDefined(imageOnly ? titleText : undefined)}"
      alt=${altText}
      src=${imageSrc}
      @error=${() => (this._isInvalidImageSrc = true)} />`;
        const initials = personDetailsInternal ? this.getInitials(personDetailsInternal) : '';
        const hasInitials = initials === null || initials === void 0 ? void 0 : initials.length;
        const textClasses = classMap({
            initials: hasInitials && !hasImage,
            'contact-icon': !hasInitials
        });
        const contactIconTemplate = html `<i>${this.renderPersonIcon()}</i>`;
        // consider the image to presentational if the view is anything other than image.
        // this reduces the redundant announcement of the user's name.
        const textTemplate = html `
      <span 
        title="${ifDefined(this.view === 'image' ? titleText : undefined)}"
        role="${ifDefined(this.view === 'image' ? undefined : 'presentation')}"
        class="${textClasses}"
      >
        ${hasInitials ? initials : contactIconTemplate}
      </span>
`;
        if (hasImage) {
            this.fireCustomEvent('person-image-rendered');
        }
        else {
            this.fireCustomEvent('person-icon-rendered');
        }
        return hasImage ? imageTemplate : textTemplate;
    }
    /**
     * Render presence for the person.
     *
     * @param presence
     * @memberof MgtPerson
     * @returns
     */
    renderPresence(presence) {
        var _a;
        if (!this.showPresence || !presence) {
            return html ``;
        }
        let presenceIcon;
        const { activity, availability } = presence;
        switch (availability) {
            case 'Available':
            case 'AvailableIdle':
                switch (activity) {
                    case 'OutOfOffice':
                        presenceIcon = getSvg(SvgIcon.PresenceOofAvailable);
                        break;
                    // OutOfOffice and Uknowns
                    case 'Available':
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceAvailable);
                        break;
                }
                break;
            case 'Busy':
            case 'BusyIdle':
                switch (activity) {
                    case 'OutOfOffice':
                    case 'OnACall':
                        presenceIcon = getSvg(SvgIcon.PresenceOofBusy);
                        break;
                    // Busy,InACall,InAConferenceCall,InAMeeting, Unknown
                    case 'Busy':
                    case 'InACall':
                    case 'InAMeeting':
                    case 'InAConferenceCall':
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceBusy);
                        break;
                }
                break;
            case 'DoNotDisturb':
                switch (activity) {
                    case 'OutOfOffice':
                        presenceIcon = getSvg(SvgIcon.PresenceOofDnd);
                        break;
                    case 'Presenting':
                    case 'Focusing':
                    case 'UrgentInterruptionsOnly':
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceDnd);
                        break;
                }
                break;
            case 'Away':
                switch (activity) {
                    case 'OutOfOffice':
                        presenceIcon = getSvg(SvgIcon.PresenceOofAway);
                        break;
                    case 'AwayLastSeenTime':
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceAway);
                        break;
                }
                break;
            case 'BeRightBack':
                switch (activity) {
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceAway);
                        break;
                }
                break;
            case 'Offline':
                switch (activity) {
                    case 'Offline':
                        presenceIcon = getSvg(SvgIcon.PresenceOffline);
                        break;
                    case 'OutOfOffice':
                    case 'OffWork':
                        presenceIcon = getSvg(SvgIcon.PresenceOofAway);
                        break;
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceStatusUnknown);
                        break;
                }
                break;
            default:
                presenceIcon = getSvg(SvgIcon.PresenceStatusUnknown);
                break;
        }
        const presenceWrapperClasses = classMap({
            'presence-wrapper': true,
            noline: this.isNoLine(),
            oneline: this.isOneLine()
        });
        const formattedActivity = (_a = this.strings[activity]) !== null && _a !== void 0 ? _a : nothing;
        return html `
      <span
        class="${presenceWrapperClasses}"
        title="${formattedActivity}"
        aria-label="${formattedActivity}"
        role="img">
          ${presenceIcon}
      </span>
    `;
    }
    /**
     * Render image with presence for the person.
     *
     * @protected
     * @param
     * @memberof MgtPersonCard
     */
    renderAvatar(personDetailsInternal, image, presence) {
        const imageTemplate = this.renderImage(personDetailsInternal, image);
        const presenceTemplate = this.renderPresence(presence);
        return html `
      <div class="avatar-wrapper">
        ${imageTemplate}
        ${presenceTemplate}
      </div>
    `;
    }
    handleLine1Clicked() {
        this.fireCustomEvent('line1clicked', this.personDetailsInternal);
    }
    handleLine2Clicked() {
        this.fireCustomEvent('line2clicked', this.personDetailsInternal);
    }
    handleLine3Clicked() {
        this.fireCustomEvent('line3clicked', this.personDetailsInternal);
    }
    handleLine4Clicked() {
        this.fireCustomEvent('line4clicked', this.personDetailsInternal);
    }
    /**
     * Render the details part of the person template.
     *
     * @param personProps
     * @param presence
     * @memberof MgtPerson
     * @returns
     */
    renderDetails(personProps, presence) {
        if (!personProps || this.view === 'image') {
            return html ``;
        }
        const person = personProps;
        if (presence) {
            person.presenceActivity = presence === null || presence === void 0 ? void 0 : presence.activity;
            person.presenceAvailability = presence === null || presence === void 0 ? void 0 : presence.availability;
        }
        const details = [];
        // we already returned on image, so we must have a first line
        const line1text = this.getTextFromProperty(person, this.line1Property);
        if (this.hasTemplate('line1')) {
            // Render the line1 template
            const template = this.renderTemplate('line1', { person });
            details.push(html `
           <div class="line1" part="detail-line" @click=${() => this.handleLine1Clicked()} role="presentation" aria-label="${line1text}">${template}</div>
         `);
        }
        else {
            // Render the line1 property value
            if (line1text) {
                details.push(html `
             <div class="line1" part="detail-line" @click=${() => this.handleLine1Clicked()} role="presentation" aria-label="${line1text}">${line1text}</div>
           `);
            }
        }
        // if we have more than one line we add the second line
        if (this.view !== 'oneline') {
            const text = this.getTextFromProperty(person, this.line2Property);
            if (this.hasTemplate('line2')) {
                // Render the line2 template
                const template = this.renderTemplate('line2', { person });
                details.push(html `
           <div class="line2" part="detail-line" @click=${() => this.handleLine2Clicked()} role="presentation" aria-label="${text}">${template}</div>
         `);
            }
            else {
                // Render the line2 property value
                if (text) {
                    details.push(html `
             <div class="line2" part="detail-line" @click=${() => this.handleLine2Clicked()} role="presentation" aria-label="${text}">${text}</div>
           `);
                }
            }
        }
        // if we have a third or fourth line we add the third line
        if (this.view === 'threelines' || this.view === 'fourlines') {
            const text = this.getTextFromProperty(person, this.line3Property);
            if (this.hasTemplate('line3')) {
                // Render the line3 template
                const template = this.renderTemplate('line3', { person });
                details.push(html `
           <div class="line3" part="detail-line" @click=${() => this.handleLine3Clicked()} role="presentation" aria-label="${text}">${template}</div>
         `);
            }
            else {
                // Render the line3 property value
                if (text) {
                    details.push(html `
             <div class="line3" part="detail-line" @click=${() => this.handleLine3Clicked()} role="presentation" aria-label="${text}">${text}</div>
           `);
                }
            }
        }
        // add the fourth line if necessary
        if (this.view === 'fourlines') {
            const text = this.getTextFromProperty(person, this.line4Property);
            if (this.hasTemplate('line4')) {
                // Render the line4 template
                const template = this.renderTemplate('line4', { person });
                details.push(html `
          <div class="line4" part="detail-line" @click=${() => this.handleLine4Clicked()} role="presentation" aria-label="${text}">${template}</div>
        `);
            }
            else {
                // Render the line4 property value
                if (text) {
                    details.push(html `
            <div class="line4" part="detail-line" @click=${() => this.handleLine4Clicked()} role="presentation" aria-label="${text}">${text}</div>
          `);
                }
            }
        }
        const detailsClasses = classMap({
            'details-wrapper': true,
            vertical: this.isVertical()
        });
        return html `
      <div class="${detailsClasses}">
        ${details}
      </div>
    `;
    }
    /**
     * Render the details flyout.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPerson
     */
    renderFlyout(anchor, personDetails, image, presence) {
        const flyoutContent = this._personCardShouldRender && this._hasLoadedPersonCard
            ? html `
           <div slot="flyout" data-testid="flyout-slot">
             ${this.renderFlyoutContent(personDetails, image, presence)}
           </div>`
            : html ``;
        const slotClasses = classMap({
            small: !this.isThreeLines() && !this.isFourLines() && !this.isLargeAvatar(),
            large: this.avatarSize !== 'auto' && this.isLargeAvatar(),
            noline: this.isNoLine(),
            oneline: this.isOneLine(),
            twolines: this.isTwoLines(),
            threelines: this.isThreeLines(),
            fourlines: this.isFourLines(),
            vertical: this.isVertical()
        });
        return mgtHtml `
      <mgt-flyout light-dismiss class="flyout" .avoidHidingAnchor=${false}>
        <div slot="anchor" class="${slotClasses}">${anchor}</div>
        ${flyoutContent}
      </mgt-flyout>`;
    }
    /**
     * Render the flyout menu content.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPerson
     */
    renderFlyoutContent(personDetails, image, presence) {
        this.fireCustomEvent('flyout-content-rendered');
        return (this.renderTemplate('person-card', { person: personDetails, personImage: image }) ||
            mgtHtml `
        <mgt-person-card
          class="mgt-person-card"
          lock-tab-navigation
          .personDetails=${personDetails}
          .personImage=${image}
          .personPresence=${presence}
          .showPresence=${this.showPresence}>
        </mgt-person-card>`);
    }
    args() {
        return [
            this.providerState,
            this.verticalLayout,
            this.view,
            this.fallbackDetails,
            this.line1Property,
            this.line2Property,
            this.line3Property,
            this.line4Property,
            this.fetchImage,
            this.avatarType,
            this.userId,
            this.personQuery,
            this.disableImageFetch,
            this.showPresence,
            this.personPresence,
            this.personDetails
        ];
    }
    /**
     * load state into the component.
     *
     * @protected
     * @returns
     * @memberof MgtPerson
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            if (!provider || provider.state === ProviderState.Loading) {
                return;
            }
            if (provider && provider.state === ProviderState.SignedOut) {
                this.personDetailsInternal = null;
                return;
            }
            const graph = provider.graph.forComponent(this);
            if ((this.verticalLayout && this.view !== 'fourlines') || this.fallbackDetails) {
                this.line2Property = 'email';
            }
            // Prepare person props
            let personProps = [
                ...defaultPersonProperties,
                this.line1Property,
                this.line2Property,
                this.line3Property,
                this.line4Property
            ];
            personProps = personProps.filter(email => email !== 'email');
            let details = this.personDetailsInternal || this.personDetails;
            if (details) {
                if (!details.personImage &&
                    this.fetchImage &&
                    this.avatarType === 'photo' &&
                    !this.personImage &&
                    !this._fetchedImage) {
                    let image;
                    if ('groupTypes' in details) {
                        image = yield getGroupImage(graph, details);
                    }
                    else {
                        image = yield getPersonImage(graph, details, MgtPerson.config.useContactApis);
                    }
                    if (image) {
                        details.personImage = image;
                        this._fetchedImage = image;
                    }
                }
            }
            else if (this.userId || this.personQuery === 'me') {
                // Use userId or 'me' query to get the person and image
                let person;
                if (this.avatarType === 'photo' && !this.disableImageFetch) {
                    person = yield getUserWithPhoto(graph, this.userId, personProps);
                }
                else {
                    if (this.personQuery === 'me') {
                        person = yield getMe(graph, personProps);
                    }
                    else {
                        person = yield getUser(graph, this.userId, personProps);
                    }
                }
                this.personDetailsInternal = person;
                this.personDetails = person;
                this._fetchedImage = this.getImage();
            }
            else if (this.personQuery) {
                // Use the personQuery to find our person.
                let people = yield findPeople(graph, this.personQuery, 1);
                if (!people || people.length === 0) {
                    people = (yield findUsers(graph, this.personQuery, 1)) || [];
                }
                if (people === null || people === void 0 ? void 0 : people.length) {
                    this.personDetailsInternal = people[0];
                    this.personDetails = people[0];
                    if (this.avatarType === 'photo' && !this.disableImageFetch) {
                        const image = yield getPersonImage(graph, people[0], MgtPerson.config.useContactApis);
                        if (image) {
                            this.personDetailsInternal.personImage = image;
                            this.personDetails.personImage = image;
                            this._fetchedImage = image;
                        }
                    }
                }
            }
            details = this.personDetailsInternal || this.personDetails || this.fallbackDetails;
            // load card data at this point
            if (this.personCardInteraction !== 'none') {
                // perform the batch requests and cache
                void getPersonCardGraphData(graph, details, this.personQuery === 'me');
            }
            // populate presence
            const defaultPresence = {
                activity: 'Offline',
                availability: 'Offline',
                id: null
            };
            if (this.showPresence && !this.personPresence && !this._fetchedPresence) {
                try {
                    if (details) {
                        // setting userId to 'me' ensures only the presence.read permission is required
                        const userId = this.personQuery !== 'me' ? details === null || details === void 0 ? void 0 : details.id : null;
                        this._fetchedPresence = yield getUserPresence(graph, userId);
                    }
                    else {
                        this._fetchedPresence = defaultPresence;
                    }
                }
                catch (_) {
                    // set up a default Presence in case beta api changes or getting error code
                    this._fetchedPresence = defaultPresence;
                }
            }
        });
    }
    /**
     * Gets the user initials
     *
     * @protected
     * @returns {string}
     * @memberof MgtPerson
     */
    getInitials(person) {
        var _a, _b, _c, _d, _e, _f;
        if (!person) {
            person = this.personDetailsInternal;
        }
        if (isContact(person)) {
            return person.initials;
        }
        let initials = '';
        if (isUser(person)) {
            initials += (_c = (_b = (_a = person.givenName) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.toUpperCase()) !== null && _c !== void 0 ? _c : '';
            initials += (_f = (_e = (_d = person.surname) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.toUpperCase()) !== null && _f !== void 0 ? _f : '';
        }
        if (!initials && person.displayName) {
            const name = person.displayName.split(/\s+/);
            for (let i = 0; i < 2 && i < name.length; i++) {
                if (name[i][0] && this.isLetter(name[i][0])) {
                    initials += name[i][0].toUpperCase();
                }
            }
        }
        return initials;
    }
    getImage() {
        if (this.personImage) {
            return this.personImage;
        }
        if (this._fetchedImage) {
            return this._fetchedImage;
        }
        const person = this.personDetailsInternal || this.personDetails;
        return (person === null || person === void 0 ? void 0 : person.personImage) ? person.personImage : null;
    }
    isLetter(char) {
        try {
            return char.match(new RegExp('\\p{L}', 'u'));
        }
        catch (e) {
            return char.toLowerCase() !== char.toUpperCase();
        }
    }
    getTextFromProperty(personDetailsInternal, prop) {
        if (!prop || prop.length === 0) {
            return null;
        }
        const properties = prop.trim().split(',');
        let text;
        let i = 0;
        while (!text && i < properties.length) {
            const currentProp = properties[i].trim();
            switch (currentProp) {
                case 'mail':
                case 'email':
                    text = getEmailFromGraphEntity(personDetailsInternal);
                    break;
                default:
                    text = personDetailsInternal[currentProp];
            }
            i++;
        }
        return text;
    }
    isLargeAvatar() {
        return (this.avatarSize === 'large' || (this.avatarSize === 'auto' && this.view !== 'image' && this.view !== 'oneline'));
    }
    isNoLine() {
        return this.view === 'image';
    }
    isOneLine() {
        return this.view === 'oneline';
    }
    isTwoLines() {
        return this.view === 'twolines';
    }
    isThreeLines() {
        return this.view === 'threelines';
    }
    isFourLines() {
        return this.view === 'fourlines';
    }
    isVertical() {
        return this.verticalLayout;
    }
}
/**
 * Global Configuration object for all
 * person components
 *
 * @static
 * @type {MgtPersonConfig}
 * @memberof MgtPerson
 */
MgtPerson.config = {
    useContactApis: true
};
__decorate([
    property({
        attribute: 'person-query'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPerson.prototype, "personQuery", null);
__decorate([
    property({
        attribute: 'fallback-details',
        type: Object
    }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPerson.prototype, "fallbackDetails", null);
__decorate([
    property({
        attribute: 'user-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPerson.prototype, "userId", null);
__decorate([
    property({
        attribute: 'usage'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPerson.prototype, "usage", null);
__decorate([
    property({
        attribute: 'show-presence',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "showPresence", void 0);
__decorate([
    property({
        attribute: 'avatar-size',
        type: String
    }),
    __metadata("design:type", String)
], MgtPerson.prototype, "avatarSize", void 0);
__decorate([
    state(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPerson.prototype, "personDetailsInternal", null);
__decorate([
    property({
        attribute: 'person-details',
        type: Object
    }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPerson.prototype, "personDetails", null);
__decorate([
    property({
        attribute: 'person-image',
        type: String
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPerson.prototype, "personImage", null);
__decorate([
    property({
        attribute: 'fetch-image',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "fetchImage", void 0);
__decorate([
    property({
        attribute: 'disable-image-fetch',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "disableImageFetch", void 0);
__decorate([
    property({
        attribute: 'vertical-layout',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "verticalLayout", void 0);
__decorate([
    property({
        attribute: 'avatar-type',
        converter: (value) => avatarTypeConverter(value, 'photo')
    }),
    __metadata("design:type", String)
], MgtPerson.prototype, "avatarType", void 0);
__decorate([
    property({
        attribute: 'person-presence',
        type: Object
    }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPerson.prototype, "personPresence", null);
__decorate([
    property({
        attribute: 'person-card',
        converter: value => personCardConverter(value)
    }),
    __metadata("design:type", String)
], MgtPerson.prototype, "personCardInteraction", void 0);
__decorate([
    property({ attribute: 'line1-property' }),
    __metadata("design:type", String)
], MgtPerson.prototype, "line1Property", void 0);
__decorate([
    property({ attribute: 'line2-property' }),
    __metadata("design:type", String)
], MgtPerson.prototype, "line2Property", void 0);
__decorate([
    property({ attribute: 'line3-property' }),
    __metadata("design:type", String)
], MgtPerson.prototype, "line3Property", void 0);
__decorate([
    property({ attribute: 'line4-property' }),
    __metadata("design:type", String)
], MgtPerson.prototype, "line4Property", void 0);
__decorate([
    property({
        converter: value => viewTypeConverter(value, 'image')
    }),
    __metadata("design:type", String)
], MgtPerson.prototype, "view", void 0);
__decorate([
    state(),
    __metadata("design:type", String)
], MgtPerson.prototype, "_fetchedImage", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtPerson.prototype, "_fetchedPresence", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "_isInvalidImageSrc", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "_personCardShouldRender", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtPerson.prototype, "_hasLoadedPersonCard", void 0);
//# sourceMappingURL=mgt-person.js.map