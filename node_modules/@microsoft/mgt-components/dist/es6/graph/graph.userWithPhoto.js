/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CacheService, prepScopes } from '@microsoft/mgt-element';
import { anyUserValidPhotoScopes, currentUserValidPhotoScopes, getIsPhotosCacheEnabled, getPhotoForResource, getPhotoFromCache, getPhotoInvalidationTime, storePhotoInCache } from './graph.photos';
import { getIsUsersCacheEnabled, getUserInvalidationTime } from './graph.user';
import { schemas } from './cacheStores';
import { isGraphError } from './isGraphError';
/**
 * async promise, returns IDynamicPerson
 *
 * @param {string} userId
 * @returns {(Promise<IDynamicPerson>)}
 * @memberof Graph
 */
export const getUserWithPhoto = (graph, userId, requestedProps) => __awaiter(void 0, void 0, void 0, function* () {
    const anyUserValidScopes = [
        'User.ReadBasic.All',
        'User.Read.All',
        'Directory.Read.All',
        'User.ReadWrite.All',
        'Directory.ReadWrite.All'
    ];
    const currentUserValidScopes = ['User.Read', 'User.ReadWrite', ...anyUserValidScopes];
    const requiredUserScopes = userId ? anyUserValidScopes : currentUserValidScopes;
    const requiredPhotoScopes = userId ? anyUserValidPhotoScopes : currentUserValidPhotoScopes;
    let photo;
    let user = null;
    let cachedPhoto;
    let cachedUser;
    const resource = userId ? `users/${userId}` : 'me';
    const fullResource = resource + (requestedProps ? `?$select=${requestedProps.toString()}` : '');
    // attempt to get user and photo from cache if enabled
    if (getIsUsersCacheEnabled()) {
        const cache = CacheService.getCache(schemas.users, schemas.users.stores.users);
        cachedUser = yield cache.getValue(userId || 'me');
        if (cachedUser && getUserInvalidationTime() > Date.now() - cachedUser.timeCached) {
            user = cachedUser.user ? JSON.parse(cachedUser.user) : null;
            if (user !== null && requestedProps) {
                const uniqueProps = requestedProps.filter(prop => !Object.keys(user).includes(prop));
                if (uniqueProps.length >= 1) {
                    user = null;
                    cachedUser = null;
                }
            }
        }
        else {
            cachedUser = null;
        }
    }
    if (getIsPhotosCacheEnabled()) {
        cachedPhoto = yield getPhotoFromCache(userId || 'me', schemas.photos.stores.users);
        if (cachedPhoto && getPhotoInvalidationTime() > Date.now() - cachedPhoto.timeCached) {
            photo = cachedPhoto.photo;
        }
        else if (cachedPhoto) {
            try {
                const response = (yield graph.api(`${resource}/photo`).get());
                if ((response === null || response === void 0 ? void 0 : response['@odata.mediaEtag']) && response['@odata.mediaEtag'] === cachedPhoto.eTag) {
                    // put current image into the cache to update the timestamp since etag is the same
                    yield storePhotoInCache(userId || 'me', schemas.photos.stores.users, cachedPhoto);
                    photo = cachedPhoto.photo;
                }
                else {
                    cachedPhoto = null;
                }
            }
            catch (e) {
                if (isGraphError(e)) {
                    // if 404 received (photo not found) but user already in cache, update timeCache value to prevent repeated 404 error / graph calls on each page refresh
                    if (e.code === 'ErrorItemNotFound' || e.code === 'ImageNotFound') {
                        yield storePhotoInCache(userId || 'me', schemas.photos.stores.users, { eTag: null, photo: null });
                    }
                }
            }
        }
    }
    // if both are not in the cache, batch get them
    if (!cachedPhoto && !cachedUser) {
        let eTag;
        // batch calls
        const batch = graph.createBatch();
        if (userId) {
            batch.get('user', `/users/${userId}${requestedProps ? '?$select=' + requestedProps.toString() : ''}`, requiredUserScopes);
            batch.get('photo', `users/${userId}/photo/$value`, requiredPhotoScopes);
        }
        else {
            batch.get('user', 'me', requiredUserScopes);
            batch.get('photo', 'me/photo/$value', requiredPhotoScopes);
        }
        const response = yield batch.executeAll();
        const photoResponse = response.get('photo');
        if (photoResponse) {
            // eslint-disable-next-line @typescript-eslint/dot-notation
            eTag = photoResponse.headers['ETag'];
            photo = photoResponse.content;
        }
        const userResponse = response.get('user');
        if (userResponse) {
            user = userResponse.content;
        }
        // store user & photo in their respective cache
        if (getIsUsersCacheEnabled()) {
            const cache = CacheService.getCache(schemas.users, schemas.users.stores.users);
            yield cache.putValue(userId || 'me', { user: JSON.stringify(user) });
        }
        if (getIsPhotosCacheEnabled()) {
            yield storePhotoInCache(userId || 'me', schemas.photos.stores.users, { eTag, photo });
        }
    }
    else if (!cachedPhoto) {
        try {
            // if only photo or user is not cached, get it individually
            const response = yield getPhotoForResource(graph, resource, requiredPhotoScopes);
            if (response) {
                if (getIsPhotosCacheEnabled()) {
                    yield storePhotoInCache(userId || 'me', schemas.photos.stores.users, {
                        eTag: response.eTag,
                        photo: response.photo
                    });
                }
                photo = response.photo;
            }
        }
        catch (_) {
            // intentionally left empty...
        }
    }
    else if (!cachedUser) {
        // get user from graph
        try {
            const response = (yield graph
                .api(fullResource)
                .middlewareOptions(prepScopes(requiredUserScopes))
                .get());
            if (response) {
                if (getIsUsersCacheEnabled()) {
                    const cache = CacheService.getCache(schemas.users, schemas.users.stores.users);
                    yield cache.putValue(userId || 'me', { user: JSON.stringify(response) });
                }
                user = response;
            }
        }
        catch (_) {
            // intentionally left empty...
        }
    }
    if (user) {
        user.personImage = photo;
    }
    return user;
});
//# sourceMappingURL=graph.userWithPhoto.js.map