/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { html } from 'lit';
import { property, state } from 'lit/decorators.js';
import { MgtTemplatedTaskComponent, mgtHtml } from '@microsoft/mgt-element';
import { strings } from './strings';
import { fluentCombobox, fluentOption } from '@fluentui/web-components';
import { registerFluentComponents } from '../../utils/FluentComponents';
import '../../styles/style-helper';
import { styles } from './mgt-taxonomy-picker-css';
import { registerMgtGetComponent } from '../mgt-get/mgt-get';
import { registerComponent } from '@microsoft/mgt-element';
import { registerMgtSpinnerComponent } from '../sub-components/mgt-spinner/mgt-spinner';
export const registerMgtTaxonomyPickerComponent = () => {
    registerFluentComponents(fluentCombobox, fluentOption);
    registerMgtSpinnerComponent();
    registerMgtGetComponent();
    registerComponent('taxonomy-picker', MgtTaxonomyPicker);
};
/**
 * Web component that can query the Microsoft Graph API for Taxonomy
 * and render a dropdown control with terms,
 * allowing selection of a single term based on
 * the specified term set id or a combination of the specified term set id and the specified term id.
 * Uses mgt-get.
 *
 * @fires {CustomEvent<MicrosoftGraph.TermStore.Term>} selectionChanged - Fired when an option is clicked/selected
 * @export
 * @class MgtTaxonomyPicker
 * @extends {MgtTemplatedTaskComponent}
 *
 * @cssprop --taxonomy-picker-background-color - {Color} Picker component background color
 * @cssprop --taxonomy-picker-list-max-height - {String} max height for options list. Default value is 380px.
 * @cssprop --taxonomy-picker-placeholder-color - {Color} Text color for the placeholder in the picker
 * @cssprop --taxonomy-picker-placeholder-hover-color - {Color} Text color for the placeholder in the picker on hover
 */
export class MgtTaxonomyPicker extends MgtTemplatedTaskComponent {
    /**
     * The strings to be used for localizing the component.
     *
     * @readonly
     * @protected
     * @memberof MgtTaxonomyPicker
     */
    get strings() {
        return strings;
    }
    static get styles() {
        return styles;
    }
    // @state() private error: object;
    constructor() {
        super();
        /**
         * Api version to use for request.
         * Default is beta.
         *
         * @type {string}
         * @memberof MgtTaxonomyPicker
         */
        this.version = 'beta';
        /**
         * The position of the dropdown. Can be 'above' or 'below'.
         *
         * @type {string}
         * @memberof MgtTaxonomyPicker
         */
        this.position = 'below';
        /**
         * The selected term.
         *
         * @type {MicrosoftGraph.TermStore.Term}
         * @memberof MgtTaxonomyPicker
         */
        this.selectedTerm = null;
        /**
         * Enables cache on the response from the specified resource.
         * Default is false.
         *
         * @type {boolean}
         * @memberof MgtTaxonomyPicker
         */
        this.cacheEnabled = false;
        /**
         * Invalidation period of the cache for the responses in milliseconds.
         *
         * @type {number}
         * @memberof MgtTaxonomyPicker
         */
        this.cacheInvalidationPeriod = 0;
        /**
         * Renders loading spinner while terms are fetched from the Graph
         *
         * @protected
         * @returns
         * @memberof MgtTaxonomyPicker
         */
        this.renderLoading = () => {
            if (!this.terms) {
                return (this.renderTemplate('loading', null, 'loading') ||
                    mgtHtml `
        <div class="message-parent">
          <mgt-spinner></mgt-spinner>
          <div label="loading-text" aria-label="loading">
            ${this.strings.loadingMessage}
          </div>
        </div>
      `);
            }
            return this.renderContent();
        };
        /**
         * Invoked on each update to perform rendering the picker. This method must return
         * a lit-html TemplateResult. Setting properties inside this method will *not*
         * trigger the element to update.
         */
        this.renderContent = () => {
            var _a;
            // if error state, render error template
            if (this.error) {
                return this.renderError();
            }
            // if no terms are found, render no-data template
            if (this.noTerms) {
                return this.renderNoData();
            }
            // if terms are found, render picker else render get
            return ((_a = this.terms) === null || _a === void 0 ? void 0 : _a.length) > 0 ? this.renderTaxonomyPicker() : this.renderGet();
        };
        /**
         * Render the no-data state.
         *
         * @protected
         * @returns {TemplateResult}
         * @memberof MgtTaxonomyPicker
         */
        this.renderError = () => this.renderTemplate('error', null, 'error') || html `<span>${this.error}</span>`;
        this.placeholder = this.strings.comboboxPlaceholder;
        this.noTerms = false;
    }
    /**
     * Refresh the data
     *
     * @param {boolean} [hardRefresh=false]
     * if false (default), the component will only update if the data changed
     * if true, the data will be first cleared and reloaded completely
     * @memberof MgtTaxonomyPicker
     */
    refresh(hardRefresh = false) {
        if (hardRefresh) {
            this.clearState();
        }
    }
    /**
     * Clears the state of the component
     *
     * @protected
     * @memberof MgtTaxonomyPicker
     */
    clearState() {
        this.terms = null;
        this.error = null;
        this.noTerms = false;
    }
    /**
     * Render the no-data state.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtTaxonomyPicker
     */
    renderNoData() {
        return this.renderTemplate('no-data', null) || html `<span>${this.strings.noTermsFound}</span>`;
    }
    /**
     * Render picker.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtTaxonomyPicker
     */
    renderTaxonomyPicker() {
        return mgtHtml `
      <fluent-combobox class="taxonomy-picker" autocomplete="both" placeholder=${this.placeholder} position=${this.position} ?disabled=${this.disabled}>
        ${this.terms.map(term => this.renderTaxonomyPickerItem(term))}
      </fluent-combobox>
     `;
    }
    /**
     * Render picker item.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtTaxonomyPicker
     */
    renderTaxonomyPickerItem(term) {
        const selected = this.defaultSelectedTermId && this.defaultSelectedTermId === term.id;
        return html `
        <fluent-option value=${term.id} ?selected=${selected} @click=${(e) => this.handleClick(e, term)}> ${this.renderTemplate('term', { term }, term.id) || term.labels[0].name} </fluent-option>
        `;
    }
    /**
     * Render picker.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtTaxonomyPicker
     */
    renderGet() {
        // if termsetId is not specified, return error message
        if (!this.termsetId) {
            return html `<span>${this.strings.termsetIdRequired}</span>`;
        }
        let resource = `/termStore/sets/${this.termsetId}/children`;
        // if both termsetId and termId are specified, then set resource to /termStore/sets/{termsetId}/terms/{termId}/children
        if (this.termId) {
            resource = `/termStore/sets/${this.termsetId}/terms/${this.termId}/children`;
        }
        // if siteId is specified, then prefix /sites/{siteId}/ to the resource
        if (this.siteId) {
            resource = `/sites/${this.siteId}${resource}`;
        }
        // Add properties to select to the resource
        resource += '?$select=id,labels,descriptions,properties';
        return mgtHtml `
      <mgt-get
        class="mgt-get"
        resource=${resource}
        version=${this.version}
        scopes="TermStore.Read.All, TermStore.ReadWrite.All"
        ?cache-enabled=${this.cacheEnabled}
        ?cache-invalidation-period=${this.cacheInvalidationPeriod}>
      </mgt-get>`;
    }
    firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        const parent = this.renderRoot;
        parent.addEventListener('dataChange', (e) => this.handleDataChange(e));
    }
    handleDataChange(e) {
        const error = e.detail.error ? e.detail.error : null;
        if (error) {
            this.error = error;
            return;
        }
        // if locale is specified, then convert it to lower case
        if (this.locale) {
            this.locale = this.locale.toLowerCase();
        }
        const response = e.detail.response.value;
        // if response is not null and has values, if locale is specified, then
        // get the label in response that has languageTag equal to locale and make it the first label and append the rest of the labels
        const terms = response.map((item) => {
            const labels = item.labels;
            if (labels && labels.length > 0) {
                if (this.locale) {
                    const label = labels.find(l => l.languageTag.toLowerCase() === this.locale);
                    if (label) {
                        item.labels = [label, ...labels.filter(l => l.languageTag.toLowerCase() !== this.locale)];
                    }
                }
            }
            return item;
        });
        this.terms = terms;
        //  if there are no terms then set noTerms to true
        if (terms.length === 0) {
            this.noTerms = true;
        }
    }
    handleClick(e, item) {
        this.selectedTerm = item;
        this.fireCustomEvent('selectionChanged', item);
    }
}
__decorate([
    property({
        attribute: 'term-set-id',
        type: String
    }),
    __metadata("design:type", String)
], MgtTaxonomyPicker.prototype, "termsetId", void 0);
__decorate([
    property({
        attribute: 'term-id',
        type: String
    }),
    __metadata("design:type", String)
], MgtTaxonomyPicker.prototype, "termId", void 0);
__decorate([
    property({
        attribute: 'site-id',
        type: String
    }),
    __metadata("design:type", String)
], MgtTaxonomyPicker.prototype, "siteId", void 0);
__decorate([
    property({
        attribute: 'locale',
        type: String
    }),
    __metadata("design:type", String)
], MgtTaxonomyPicker.prototype, "locale", void 0);
__decorate([
    property({
        attribute: 'version',
        type: String
    }),
    __metadata("design:type", Object)
], MgtTaxonomyPicker.prototype, "version", void 0);
__decorate([
    property({
        attribute: 'placeholder',
        type: String
    }),
    __metadata("design:type", String)
], MgtTaxonomyPicker.prototype, "placeholder", void 0);
__decorate([
    property({
        attribute: 'position',
        type: String,
        converter: (value) => {
            if (value === 'above') {
                return 'above';
            }
            return 'below';
        }
    }),
    __metadata("design:type", String)
], MgtTaxonomyPicker.prototype, "position", void 0);
__decorate([
    property({
        attribute: 'default-selected-term-id',
        type: String
    }),
    __metadata("design:type", String)
], MgtTaxonomyPicker.prototype, "defaultSelectedTermId", void 0);
__decorate([
    property({
        attribute: 'selected-term',
        type: Object
    }),
    __metadata("design:type", Object)
], MgtTaxonomyPicker.prototype, "selectedTerm", void 0);
__decorate([
    property({
        attribute: 'disabled',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtTaxonomyPicker.prototype, "disabled", void 0);
__decorate([
    property({
        attribute: 'cache-enabled',
        type: Boolean
    }),
    __metadata("design:type", Object)
], MgtTaxonomyPicker.prototype, "cacheEnabled", void 0);
__decorate([
    property({
        attribute: 'cache-invalidation-period',
        type: Number
    }),
    __metadata("design:type", Object)
], MgtTaxonomyPicker.prototype, "cacheInvalidationPeriod", void 0);
__decorate([
    state(),
    __metadata("design:type", Array)
], MgtTaxonomyPicker.prototype, "terms", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtTaxonomyPicker.prototype, "noTerms", void 0);
//# sourceMappingURL=mgt-taxonomy-picker.js.map