{"version":3,"file":"graph.presence.js","sourceRoot":"src/","sources":["graph/graph.presence.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\nimport { IGraph, prepScopes, CacheItem, CacheService, CacheStore, CollectionResponse } from '@microsoft/mgt-element';\nimport { Person, Presence } from '@microsoft/microsoft-graph-types';\nimport { schemas } from './cacheStores';\nimport { IDynamicPerson } from './types';\n\n/**\n * Object to be stored in cache representing individual people\n */\ninterface CachePresence extends CacheItem {\n  /**\n   * json representing a person stored as string\n   */\n  presence?: string;\n}\n\n/**\n * Defines the expiration time\n */\nconst getPresenceInvalidationTime = (): number =>\n  CacheService.config.presence.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;\n\n/**\n * Whether the groups store is enabled\n */\nconst getIsPresenceCacheEnabled = (): boolean =>\n  CacheService.config.presence.isEnabled && CacheService.config.isEnabled;\n\n/**\n * async promise, allows developer to get user presence\n *\n * @returns {Promise<Presence>}\n * @param {IGraph} graph\n * @param {string} userId - id for the user or null for current signed in user\n * @memberof BetaGraph\n */\nexport const getUserPresence = async (graph: IGraph, userId?: string): Promise<Presence> => {\n  let cache: CacheStore<CachePresence>;\n\n  if (getIsPresenceCacheEnabled()) {\n    cache = CacheService.getCache(schemas.presence, schemas.presence.stores.presence);\n    const presence = await cache.getValue(userId || 'me');\n    if (presence && getPresenceInvalidationTime() > Date.now() - presence.timeCached) {\n      return JSON.parse(presence.presence) as Presence;\n    }\n  }\n\n  const validScopes = userId ? ['presence.read.all'] : ['presence.read', 'presence.read.all'];\n  const resource = userId ? `/users/${userId}/presence` : '/me/presence';\n\n  const result = (await graph.api(resource).middlewareOptions(prepScopes(validScopes)).get()) as Presence;\n  if (getIsPresenceCacheEnabled()) {\n    await cache.putValue(userId || 'me', { presence: JSON.stringify(result) });\n  }\n\n  return result;\n};\n\n/**\n * async promise, allows developer to get person presense by providing array of IDynamicPerson\n *\n * @returns {}\n * @memberof BetaGraph\n */\nexport const getUsersPresenceByPeople = async (graph: IGraph, people?: IDynamicPerson[]) => {\n  if (!people || people.length === 0) {\n    return {};\n  }\n\n  const peoplePresence: Record<string, Presence> = {};\n  const peoplePresenceToQuery: string[] = [];\n  const validScopes = ['presence.read.all'];\n  let cache: CacheStore<CachePresence>;\n\n  if (getIsPresenceCacheEnabled()) {\n    cache = CacheService.getCache(schemas.presence, schemas.presence.stores.presence);\n  }\n\n  for (const person of people) {\n    if (person?.id) {\n      const id = person.id;\n      peoplePresence[id] = null;\n      let presence: CachePresence;\n      if (getIsPresenceCacheEnabled()) {\n        presence = await cache.getValue(id);\n      }\n      if (getIsPresenceCacheEnabled() && presence && getPresenceInvalidationTime() > Date.now() - presence.timeCached) {\n        peoplePresence[id] = JSON.parse(presence.presence) as Presence;\n      } else {\n        peoplePresenceToQuery.push(id);\n      }\n    }\n  }\n\n  try {\n    if (peoplePresenceToQuery.length > 0) {\n      const presenceResult = (await graph\n        .api('/communications/getPresencesByUserId')\n        .middlewareOptions(prepScopes(validScopes))\n        .post({\n          ids: peoplePresenceToQuery\n        })) as CollectionResponse<Presence>;\n\n      for (const r of presenceResult.value) {\n        peoplePresence[r.id] = r;\n        if (getIsPresenceCacheEnabled()) {\n          await cache.putValue(r.id, { presence: JSON.stringify(r) });\n        }\n      }\n    }\n\n    return peoplePresence;\n  } catch (_) {\n    try {\n      /**\n       * individual calls to getUserPresence as fallback\n       * must filter out the contacts, which will either 404 or have PresenceUnknown response\n       * caching will be handled by getUserPresence\n       */\n      const response = await Promise.all(\n        people\n          .filter(\n            person =>\n              person?.id &&\n              !peoplePresence[person.id] &&\n              'personType' in person &&\n              (person as Person).personType.subclass === 'OrganizationUser'\n          )\n          .map(person => getUserPresence(graph, person.id))\n      );\n\n      for (const r of response) {\n        peoplePresence[r.id] = r;\n      }\n      return peoplePresence;\n    } catch (e) {\n      return null;\n    }\n  }\n};\n"]}