/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CacheService, prepScopes } from '@microsoft/mgt-element';
import { schemas } from './cacheStores';
import { findPeople } from './graph.people';
/**
 * Defines the time it takes for objects in the cache to expire
 */
export const getUserInvalidationTime = () => CacheService.config.users.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
/**
 * Whether or not the cache is enabled
 */
export const getIsUsersCacheEnabled = () => CacheService.config.users.isEnabled && CacheService.config.isEnabled;
export const getUsers = (graph, userFilters = '', top = 10) => __awaiter(void 0, void 0, void 0, function* () {
    const allValidScopes = [
        'User.ReadBasic.All',
        'User.Read.All',
        'Directory.Read.All',
        'User.ReadWrite.All',
        'Directory.ReadWrite.All'
    ];
    const apiString = '/users';
    let cache;
    const cacheKey = `${userFilters === '' ? '*' : userFilters}:${top}`;
    const cacheItem = { maxResults: top, results: null };
    if (getIsUsersCacheEnabled()) {
        cache = CacheService.getCache(schemas.users, schemas.users.stores.userFilters);
        const cacheRes = yield cache.getValue(cacheKey);
        if (cacheRes && getUserInvalidationTime() > Date.now() - cacheRes.timeCached) {
            return cacheRes.results.map(userStr => JSON.parse(userStr));
        }
    }
    const graphClient = graph.api(apiString).top(top);
    if (userFilters) {
        graphClient.filter(userFilters).header('ConsistencyLevel', 'eventual').count(true);
    }
    try {
        const response = (yield graphClient
            .middlewareOptions(prepScopes(allValidScopes))
            .get());
        if (getIsUsersCacheEnabled() && response) {
            cacheItem.results = response.value.map(userStr => JSON.stringify(userStr));
            yield cache.putValue(userFilters, cacheItem);
        }
        return response.value;
        // eslint-disable-next-line no-empty
    }
    catch (error) { }
});
const allValidMeScopes = ['User.Read', 'User.ReadWrite'];
/**
 * async promise, returns Graph User data relating to the user logged in
 *
 * @returns {(Promise<User>)}
 * @memberof Graph
 */
export const getMe = (graph, requestedProps) => __awaiter(void 0, void 0, void 0, function* () {
    // for the /me call we'll only use the single User.Read and User.ReadWrite permissions
    // as they are explicitly scoped to the current user
    let cache;
    if (getIsUsersCacheEnabled()) {
        cache = CacheService.getCache(schemas.users, schemas.users.stores.users);
        const me = yield cache.getValue('me');
        if (me && getUserInvalidationTime() > Date.now() - me.timeCached) {
            const cachedData = JSON.parse(me.user);
            const uniqueProps = requestedProps
                ? requestedProps.filter(prop => !Object.keys(cachedData).includes(prop))
                : null;
            // if requestedProps doesn't contain any unique props other than "@odata.context"
            if (!uniqueProps || uniqueProps.length <= 1) {
                return cachedData;
            }
        }
    }
    let apiString = 'me';
    if (requestedProps) {
        apiString = apiString + '?$select=' + requestedProps.toString();
    }
    const response = (yield graph.api(apiString).middlewareOptions(prepScopes(allValidMeScopes)).get());
    if (getIsUsersCacheEnabled()) {
        yield cache.putValue('me', { user: JSON.stringify(response) });
    }
    return response;
});
export const validUserByIdScopes = [
    'User.ReadBasic.All',
    'User.Read.All',
    'Directory.Read.All',
    'User.ReadWrite.All',
    'Directory.ReadWrite.All'
];
/**
 * async promise, returns all Graph users associated with the userPrincipleName provided
 *
 * @param {string} userPrincipleName
 * @returns {(Promise<User>)}
 * @memberof Graph
 */
export const getUser = (graph, userPrincipleName, requestedProps) => __awaiter(void 0, void 0, void 0, function* () {
    let cache;
    if (getIsUsersCacheEnabled()) {
        cache = CacheService.getCache(schemas.users, schemas.users.stores.users);
        // check cache
        const user = yield cache.getValue(userPrincipleName);
        // is it stored and is timestamp good?
        if (user && getUserInvalidationTime() > Date.now() - user.timeCached) {
            const cachedData = user.user ? JSON.parse(user.user) : null;
            const uniqueProps = requestedProps && cachedData ? requestedProps.filter(prop => !Object.keys(cachedData).includes(prop)) : null;
            // return without any worries
            if (!uniqueProps || uniqueProps.length <= 1) {
                return cachedData;
            }
        }
    }
    let apiString = `/users/${userPrincipleName}`;
    if (requestedProps) {
        apiString = apiString + '?$select=' + requestedProps.toString();
    }
    // else we must grab it
    let response;
    try {
        response = (yield graph.api(apiString).middlewareOptions(prepScopes(validUserByIdScopes)).get());
        // eslint-disable-next-line no-empty
    }
    catch (_) { }
    if (getIsUsersCacheEnabled()) {
        yield cache.putValue(userPrincipleName, { user: JSON.stringify(response) });
    }
    return response;
});
/**
 * Returns a Promise of Graph Users array associated with the user ids array
 *
 * @export
 * @param {IGraph} graph
 * @param {string[]} userIds, an array of string ids
 * @returns {Promise<User[]>}
 */
export const getUsersForUserIds = (graph, userIds, searchInput = '', userFilters = '', fallbackDetails) => __awaiter(void 0, void 0, void 0, function* () {
    if (!userIds || userIds.length === 0) {
        return [];
    }
    const batch = graph.createBatch();
    const peopleDict = {};
    const peopleSearchMatches = {};
    const notInCache = [];
    searchInput = searchInput.toLowerCase();
    let cache;
    if (getIsUsersCacheEnabled()) {
        cache = CacheService.getCache(schemas.users, schemas.users.stores.users);
    }
    for (const id of userIds) {
        peopleDict[id] = null;
        let apiUrl = `/users/${id}`;
        let user;
        let cacheUser;
        if (getIsUsersCacheEnabled()) {
            cacheUser = yield cache.getValue(id);
        }
        if ((cacheUser === null || cacheUser === void 0 ? void 0 : cacheUser.user) && getUserInvalidationTime() > Date.now() - cacheUser.timeCached) {
            user = JSON.parse(cacheUser === null || cacheUser === void 0 ? void 0 : cacheUser.user);
            if (searchInput) {
                if (user) {
                    const displayName = user.displayName;
                    const searchMatches = displayName === null || displayName === void 0 ? void 0 : displayName.toLowerCase().includes(searchInput);
                    if (searchMatches) {
                        peopleSearchMatches[id] = user;
                    }
                }
            }
            else {
                if (user) {
                    peopleDict[id] = user;
                }
                else {
                    batch.get(id, apiUrl, validUserByIdScopes);
                    notInCache.push(id);
                }
            }
        }
        else if (id !== '') {
            if (id === 'me') {
                peopleDict[id] = yield getMe(graph);
            }
            else {
                apiUrl = `/users/${id}`;
                if (userFilters) {
                    apiUrl += `${apiUrl}?$filter=${userFilters}&$count=true`;
                }
                batch.get(id, apiUrl, validUserByIdScopes, userFilters ? { ConsistencyLevel: 'eventual' } : {});
                notInCache.push(id);
            }
        }
    }
    try {
        if (batch.hasRequests) {
            const responses = yield batch.executeAll();
            // iterate over userIds to ensure the order of ids
            for (const id of userIds) {
                const response = responses.get(id);
                if (response === null || response === void 0 ? void 0 : response.content) {
                    const user = response.content;
                    if (searchInput) {
                        const displayName = (user === null || user === void 0 ? void 0 : user.displayName.toLowerCase()) || '';
                        if (displayName.includes(searchInput)) {
                            peopleSearchMatches[id] = user;
                        }
                    }
                    else {
                        peopleDict[id] = user;
                    }
                    if (getIsUsersCacheEnabled()) {
                        yield cache.putValue(id, { user: JSON.stringify(user) });
                    }
                }
                else {
                    const fallback = fallbackDetails.find(detail => Object.values(detail).includes(id));
                    if (fallback) {
                        peopleDict[id] = fallback;
                    }
                }
            }
        }
        if (searchInput && Object.keys(peopleSearchMatches).length) {
            return Promise.all(Object.values(peopleSearchMatches));
        }
        return Promise.all(Object.values(peopleDict));
    }
    catch (_) {
        // fallback to making the request one by one
        try {
            // call getUser for all the users that weren't cached
            userIds
                .filter(id => notInCache.includes(id))
                .forEach(id => {
                peopleDict[id] = getUser(graph, id);
            });
            if (getIsUsersCacheEnabled()) {
                // store all users that weren't retrieved from the cache, into the cache
                yield Promise.all(userIds
                    .filter(id => notInCache.includes(id))
                    .map((id) => __awaiter(void 0, void 0, void 0, function* () { return yield cache.putValue(id, { user: JSON.stringify(yield peopleDict[id]) }); })));
            }
            return Promise.all(Object.values(peopleDict));
        }
        catch (e) {
            return [];
        }
    }
});
/**
 * Returns a Promise of Graph Users array associated with the people queries array
 *
 * @export
 * @param {IGraph} graph
 * @param {string[]} peopleQueries, an array of string ids
 * @returns {Promise<User[]>}
 */
export const getUsersForPeopleQueries = (graph, peopleQueries, fallbackDetails) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const allValidPeopleScopes = ['People.Read', 'People.Read.All'];
    if (!peopleQueries || peopleQueries.length === 0) {
        return [];
    }
    const batch = graph.createBatch();
    const people = [];
    let cacheRes;
    let cache;
    if (getIsUsersCacheEnabled()) {
        cache = CacheService.getCache(schemas.users, schemas.users.stores.usersQuery);
    }
    for (const personQuery of peopleQueries) {
        if (getIsUsersCacheEnabled()) {
            cacheRes = yield cache.getValue(personQuery);
        }
        if (getIsUsersCacheEnabled() &&
            (cacheRes === null || cacheRes === void 0 ? void 0 : cacheRes.results[0]) &&
            getUserInvalidationTime() > Date.now() - cacheRes.timeCached) {
            const person = JSON.parse(cacheRes.results[0]);
            people.push(person);
        }
        else {
            batch.get(personQuery, `/me/people?$search="${personQuery}"`, allValidPeopleScopes, {
                'X-PeopleQuery-QuerySources': 'Mailbox,Directory'
            });
        }
    }
    if (batch.hasRequests) {
        try {
            const responses = yield batch.executeAll();
            for (const personQuery of peopleQueries) {
                const response = responses.get(personQuery);
                if (((_a = response === null || response === void 0 ? void 0 : response.content) === null || _a === void 0 ? void 0 : _a.value) && response.content.value.length > 0) {
                    people.push(response.content.value[0]);
                    if (getIsUsersCacheEnabled()) {
                        yield cache.putValue(personQuery, { maxResults: 1, results: [JSON.stringify(response.content.value[0])] });
                    }
                }
                else {
                    const fallback = fallbackDetails.find(detail => Object.values(detail).includes(personQuery));
                    if (fallback) {
                        people.push(fallback);
                    }
                }
            }
            return people;
        }
        catch (_) {
            try {
                return Promise.all(peopleQueries
                    .filter(personQuery => personQuery && personQuery !== '')
                    .map((personQuery) => __awaiter(void 0, void 0, void 0, function* () {
                    const personArray = yield findPeople(graph, personQuery, 1);
                    if (personArray === null || personArray === void 0 ? void 0 : personArray.length) {
                        if (getIsUsersCacheEnabled()) {
                            yield cache.putValue(personQuery, { maxResults: 1, results: [JSON.stringify(personArray[0])] });
                        }
                        return personArray[0];
                    }
                })));
            }
            catch (e) {
                return [];
            }
        }
    }
    return people;
});
/**
 * Search Microsoft Graph for Users in the organization
 *
 * @export
 * @param {IGraph} graph
 * @param {string} query - the string to search for
 * @param {number} [top=10] - maximum number of results to return
 * @returns {Promise<User[]>}
 */
export const findUsers = (graph, query, top = 10, userFilters = '') => __awaiter(void 0, void 0, void 0, function* () {
    const scopes = validUserByIdScopes;
    const item = { maxResults: top, results: null };
    const cacheKey = `${query}:${top}:${userFilters}`;
    let cache;
    if (getIsUsersCacheEnabled()) {
        cache = CacheService.getCache(schemas.users, schemas.users.stores.usersQuery);
        const result = yield cache.getValue(cacheKey);
        if (result && getUserInvalidationTime() > Date.now() - result.timeCached) {
            return result.results.map(userStr => JSON.parse(userStr));
        }
    }
    const encodedQuery = `${query.replace(/#/g, '%2523')}`;
    const graphBuilder = graph
        .api('users')
        .search(`"displayName:${encodedQuery}" OR "mail:${encodedQuery}" OR "userPrincipalName:${encodedQuery}"`)
        .header('ConsistencyLevel', 'eventual')
        .count(true);
    let graphResult;
    if (userFilters !== '') {
        graphBuilder.filter(userFilters);
    }
    try {
        graphResult = (yield graphBuilder.top(top).middlewareOptions(prepScopes(scopes)).get());
        // eslint-disable-next-line no-empty
    }
    catch (_b) { }
    if (getIsUsersCacheEnabled() && graphResult) {
        item.results = graphResult.value.map(userStr => JSON.stringify(userStr));
        yield cache.putValue(query, item);
    }
    return graphResult ? graphResult.value : null;
});
/**
 * async promise, returns all matching Graph users who are member of the specified group
 *
 * @param {string} query
 * @param {string} groupId - the group to query
 * @param {number} [top=10] - number of people to return
 * @param {PersonType} [personType='person'] - the type of person to search for
 * @param {boolean} [transitive=false] - whether the return should contain a flat list of all nested members
 * @returns {(Promise<User[]>)}
 */
export const findGroupMembers = (graph, query, groupId, top = 10, personType = 'person', transitive = false, userFilters = '', peopleFilters = '') => __awaiter(void 0, void 0, void 0, function* () {
    const allValidScopes = [
        'GroupMember.Read.All',
        'Group.Read.All',
        'Directory.Read.All',
        'GroupMember.ReadWrite.All',
        'Group.ReadWrite.All'
    ];
    const item = { maxResults: top, results: null };
    let cache;
    const key = `${groupId || '*'}:${query || '*'}:${top}:${personType}:${transitive}:${userFilters}`;
    if (getIsUsersCacheEnabled()) {
        cache = CacheService.getCache(schemas.users, schemas.users.stores.usersQuery);
        const result = yield cache.getValue(key);
        if (result && getUserInvalidationTime() > Date.now() - result.timeCached) {
            return result.results.map(userStr => JSON.parse(userStr));
        }
    }
    let filter = '';
    if (query) {
        filter = `startswith(displayName,'${query}') or startswith(givenName,'${query}') or startswith(surname,'${query}') or startswith(mail,'${query}') or startswith(userPrincipalName,'${query}')`;
    }
    let apiUrl = `/groups/${groupId}/${transitive ? 'transitiveMembers' : 'members'}`;
    if (personType === 'person') {
        apiUrl += '/microsoft.graph.user';
    }
    else if (personType === 'group') {
        apiUrl += '/microsoft.graph.group';
        if (query) {
            filter = `startswith(displayName,'${query}') or startswith(mail,'${query}')`;
        }
    }
    if (userFilters) {
        filter += query ? ` and ${userFilters}` : userFilters;
    }
    if (peopleFilters) {
        filter += query ? ` and ${peopleFilters}` : peopleFilters;
    }
    const graphClient = graph.api(apiUrl).top(top).filter(filter);
    if (userFilters || query) {
        graphClient.header('ConsistencyLevel', 'eventual').count(true);
    }
    const graphResult = (yield graphClient
        .middlewareOptions(prepScopes(allValidScopes))
        .get());
    if (getIsUsersCacheEnabled() && graphResult) {
        item.results = graphResult.value.map(userStr => JSON.stringify(userStr));
        yield cache.putValue(key, item);
    }
    return graphResult ? graphResult.value : null;
});
export const findUsersFromGroupIds = (graph, query, groupIds, top = 10, personType = 'person', transitive = false, groupFilters = '') => __awaiter(void 0, void 0, void 0, function* () {
    const users = [];
    for (const groupId of groupIds) {
        try {
            const groupUsers = yield findGroupMembers(graph, query, groupId, top, personType, transitive, groupFilters);
            users.push(...groupUsers);
        }
        catch (_) {
            continue;
        }
    }
    return users;
});
//# sourceMappingURL=graph.user.js.map